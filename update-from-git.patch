diff --git a/CMakeLists.txt b/CMakeLists.txt
index e52e0e9..6936b31 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -16,6 +16,7 @@ set(SDDM_VERSION_MAJOR 0)
 set(SDDM_VERSION_MINOR 19)
 set(SDDM_VERSION_PATCH 0)
 set(SDDM_VERSION_STRING "${SDDM_VERSION_MAJOR}.${SDDM_VERSION_MINOR}.${SDDM_VERSION_PATCH}")
+add_compile_definitions("SDDM_VERSION=\"${SDDM_VERSION_STRING}\"")
 
 # Set up packaging
 set(CPACK_PACKAGE_NAME "sddm")
@@ -95,7 +96,7 @@ find_package(XCB REQUIRED)
 find_package(XKB REQUIRED)
 
 # Qt 5
-find_package(Qt5 5.8.0 CONFIG REQUIRED Core DBus Gui Qml Quick LinguistTools Test)
+find_package(Qt5 5.15.0 CONFIG REQUIRED Core DBus Gui Qml Quick LinguistTools Test)
 
 # find qt5 imports dir
 get_target_property(QMAKE_EXECUTABLE Qt5::qmake LOCATION)
@@ -141,7 +142,6 @@ if(SYSTEMD_FOUND)
         string(REGEX REPLACE "[ \t\n]+" "" SYSTEMD_SYSTEM_UNIT_DIR ${SYSTEMD_SYSTEM_UNIT_DIR})
     endif()
 
-    set(MINIMUM_VT 1)
     set(HALT_COMMAND "/usr/bin/systemctl poweroff")
     set(REBOOT_COMMAND "/usr/bin/systemctl reboot")
 else()
@@ -159,7 +159,6 @@ if(ELOGIND_FOUND)
     add_definitions(-DHAVE_ELOGIND)
     set(CMAKE_AUTOMOC_MOC_OPTIONS -DHAVE_ELOGIND)
 
-    set(MINIMUM_VT 7)
     set(HALT_COMMAND "/usr/bin/loginctl poweroff")
     set(REBOOT_COMMAND "/usr/bin/loginctl reboot")
 endif()
@@ -171,10 +170,8 @@ if (NOT ELOGIND_FOUND AND NOT SYSTEMD_FOUND)
     # commands for shutdown and reboot. On FreeBSD, there are
     # normally more getty's running than on Linux.
     if("${CMAKE_SYSTEM_NAME}" STREQUAL "FreeBSD")
-        set(MINIMUM_VT 9)
         set(HALT_COMMAND "/sbin/shutdown -p now")
     else()
-        set(MINIMUM_VT 7)
         set(HALT_COMMAND "/sbin/shutdown -h -P now")
     endif()
     set(REBOOT_COMMAND "/sbin/shutdown -r now")
diff --git a/ChangeLog b/ChangeLog
index ff2a68d..64ed544 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -33,9 +33,9 @@
     * Use modern connects
     * Update translations
 
-## 0.18.1 - 2019-03-31
+## 0.18.1 - 2019-03-11
 ----------------------
-    * Use C++ scoping for handling buffer deletion
+    - Fix crashes when creating a user session
 
 ## 0.18.0 - 2018-07-17
 ----------------------
diff --git a/README.md b/README.md
index 7c7a555..9c2f7d3 100644
--- a/README.md
+++ b/README.md
@@ -17,9 +17,6 @@ a combox etc.
 There are a few sample themes distributed with SDDM.
 They can be used as a starting point for new themes.
 
-SDDM is developed by volunteers, please consider [donating](https://www.bountysource.com/teams/sddm)
-money that can be used to support the features that you most desire.
-
 ## SCREENSHOTS
 
 ![sample screenshot](https://raw.github.com/sddm/sddm/master/src/greeter/theme/maui.jpg)
@@ -39,7 +36,7 @@ money that can be used to support the features that you most desire.
 
 ## INSTALLATION
 
-Qt >= 5.8.0 is required to use SDDM.
+Qt >= 5.15.0 is required to use SDDM.
 
 SDDM runs the greeter as a system user named "sddm" whose home directory needs
 to be set to `/var/lib/sddm`.
diff --git a/cmake/FindPAM.cmake b/cmake/FindPAM.cmake
index f209c0b..a64680b 100644
--- a/cmake/FindPAM.cmake
+++ b/cmake/FindPAM.cmake
@@ -13,6 +13,7 @@ endif (PAM_INCLUDE_DIR AND PAM_LIBRARY)
 find_path(PAM_INCLUDE_DIR NAMES security/pam_appl.h pam/pam_appl.h)
 find_library(PAM_LIBRARY pam)
 find_library(DL_LIBRARY dl)
+find_library(HAVE_PAM_FAILLOCK NAME pam_faillock.so PATH_SUFFIXES security)
 
 if (PAM_INCLUDE_DIR AND PAM_LIBRARY)
 	set(PAM_FOUND TRUE)
diff --git a/data/flags/bd.png b/data/flags/bd.png
new file mode 100644
index 0000000..b516bb7
Binary files /dev/null and b/data/flags/bd.png differ
diff --git a/data/man/sddm.conf.rst.in b/data/man/sddm.conf.rst.in
index bee0768..48395b2 100644
--- a/data/man/sddm.conf.rst.in
+++ b/data/man/sddm.conf.rst.in
@@ -6,7 +6,7 @@
 sddm display manager configuration
 ----------------------------------
 
-:Date: August 2015
+:Date: March 2021
 :Version: sddm @SDDM_VERSION_STRING@
 :Manual section: 5
 :Manual group: sddm
@@ -36,6 +36,15 @@ OPTIONS
 
 [General] section:
 
+`DisplayServer=`
+	Select the display server to use for the greeter.
+	Valid values are:
+	* `x11`: X server running as root.
+	* `x11-user`: X server running as unprivileged user.
+	* `wayland`: Wayland compositor as unprivileged user.
+	Default value is "x11".
+	For `x11-user` you might need to configure Xorg.wrap(1).
+
 `HaltCommand=`
 	Halt command.
 	Default value is "@HALT_COMMAND@".
@@ -85,6 +94,9 @@ OPTIONS
 	Name of the cursor theme to be set before starting
 	the display server.
 
+`CursorSize=`
+	Cursor size to be set before starting the display server.
+
 `Font=`
 	Name of the font to be set before starting the
 	display server. Please note that the theme can still override this option.
@@ -134,17 +146,21 @@ OPTIONS
 
 `DisplayCommand=`
 	Path of script to execute when starting the display server.
+	The script will be executed as root when General.DisplayServer
+	is "x11", otherwise as sddm user.
 	Default value is "@DATA_INSTALL_DIR@/scripts/Xsetup".
 
 `DisplayStopCommand=`
 	Path of script to execute when stopping the display server.
+	The script will be executed as root when General.DisplayServer
+	is "x11", otherwise as sddm user.
 	Default value is "@DATA_INSTALL_DIR@/scripts/Xstop".
 
 `MinimumVT=`
 	Minimum virtual terminal number that will be used
 	by the first display. Virtual terminal number will
 	increase as new displays added.
-	Default value is @MINIMUM_VT@.
+	This setting is no longer available since SDDM v0.20.
 
 `EnableHiDPI=`
 	Enables Qt's automatic HiDPI scaling.
@@ -153,6 +169,10 @@ OPTIONS
 
 [Wayland] section:
 
+`CompositorCommand=`
+        Path of the compositor to execute when starting the greeter.
+        Default value is "weston --shell=fullscreen-shell.so".
+
 `SessionDir=`
 	Path of the directory containing session files.
 	Default value is "/usr/share/wayland-sessions".
diff --git a/data/scripts/Xsession b/data/scripts/Xsession
index 5449810..a971d40 100755
--- a/data/scripts/Xsession
+++ b/data/scripts/Xsession
@@ -8,26 +8,13 @@
 # Note that the respective logout scripts are not sourced.
 case $SHELL in
   */bash)
-    [ -z "$BASH" ] && exec $SHELL $0 "$@"
+    [ -z "$BASH" ] && exec $SHELL --login $0 "$@"
+    shopt -q login_shell || exec $SHELL --login $0 "$@"
     set +o posix
-    [ -f /etc/profile ] && . /etc/profile
-    if [ -f $HOME/.bash_profile ]; then
-      . $HOME/.bash_profile
-    elif [ -f $HOME/.bash_login ]; then
-      . $HOME/.bash_login
-    elif [ -f $HOME/.profile ]; then
-      . $HOME/.profile
-    fi
     ;;
-*/zsh)
-    [ -z "$ZSH_NAME" ] && exec $SHELL $0 "$@"
-    [ -d /etc/zsh ] && zdir=/etc/zsh || zdir=/etc
-    zhome=${ZDOTDIR:-$HOME}
-    # zshenv is always sourced automatically.
-    [ -f $zdir/zprofile ] && . $zdir/zprofile
-    [ -f $zhome/.zprofile ] && . $zhome/.zprofile
-    [ -f $zdir/zlogin ] && . $zdir/zlogin
-    [ -f $zhome/.zlogin ] && . $zhome/.zlogin
+  */zsh)
+    [ -z "$ZSH_NAME" ] && exec $SHELL --login $0 "$@"
+    [[ -o login ]] || exec $SHELL --login $0 "$@"
     emulate -R sh
     ;;
   */csh|*/tcsh)
@@ -39,6 +26,8 @@ case $SHELL in
     rm -f $xsess_tmp
     ;;
   */fish)
+    [ -f /etc/profile ] && . /etc/profile
+    [ -f $HOME/.profile ] && . $HOME/.profile
     xsess_tmp=`mktemp /tmp/xsess-env-XXXXXX`
     $SHELL --login -c "/bin/sh -c 'export -p' > $xsess_tmp"
     . $xsess_tmp
diff --git a/data/scripts/wayland-session b/data/scripts/wayland-session
index de4f519..bbeb7ce 100755
--- a/data/scripts/wayland-session
+++ b/data/scripts/wayland-session
@@ -6,28 +6,19 @@
 # Copyright (C) 2001-2005 Oswald Buddenhagen <ossi@kde.org>
 
 # Note that the respective logout scripts are not sourced.
+
+# Backup the user shell setting into SDDM specific variable
+SDDM_USER_SHELL=$SHELL
+
 case $SHELL in
   */bash)
-    [ -z "$BASH" ] && exec $SHELL $0 "$@"
+    [ -z "$BASH" ] && exec $SHELL --login $0 "$@"
+    shopt -q login_shell || exec $SHELL --login $0 "$@"
     set +o posix
-    [ -f /etc/profile ] && . /etc/profile
-    if [ -f $HOME/.bash_profile ]; then
-      . $HOME/.bash_profile
-    elif [ -f $HOME/.bash_login ]; then
-      . $HOME/.bash_login
-    elif [ -f $HOME/.profile ]; then
-      . $HOME/.profile
-    fi
     ;;
-*/zsh)
-    [ -z "$ZSH_NAME" ] && exec $SHELL $0 "$@"
-    [ -d /etc/zsh ] && zdir=/etc/zsh || zdir=/etc
-    zhome=${ZDOTDIR:-$HOME}
-    # zshenv is always sourced automatically.
-    [ -f $zdir/zprofile ] && . $zdir/zprofile
-    [ -f $zhome/.zprofile ] && . $zhome/.zprofile
-    [ -f $zdir/zlogin ] && . $zdir/zlogin
-    [ -f $zhome/.zlogin ] && . $zhome/.zlogin
+  */zsh)
+    [ -z "$ZSH_NAME" ] && exec $SHELL --login $0 "$@"
+    [[ -o login ]] || exec $SHELL --login $0 "$@"
     emulate -R sh
     ;;
   */csh|*/tcsh)
@@ -39,6 +30,8 @@ case $SHELL in
     rm -f $wlsess_tmp
     ;;
   */fish)
+    [ -f /etc/profile ] && . /etc/profile
+    [ -f $HOME/.profile ] && . $HOME/.profile
     xsess_tmp=`mktemp /tmp/xsess-env-XXXXXX`
     $SHELL --login -c "/bin/sh -c 'export -p' > $xsess_tmp"
     . $xsess_tmp
@@ -50,4 +43,7 @@ case $SHELL in
     ;;
 esac
 
+# Restore user shell setting that may have been clobbered by setting environment
+export SHELL=$SDDM_USER_SHELL
+
 exec $@
diff --git a/data/themes/elarun/Main.qml b/data/themes/elarun/Main.qml
index 365c4f1..0408b82 100644
--- a/data/themes/elarun/Main.qml
+++ b/data/themes/elarun/Main.qml
@@ -152,7 +152,7 @@ Rectangle {
 
                     onClicked: sddm.login(user_entry.text, pw_entry.text, sessionIndex)
 
-                    KeyNavigation.backtab: pw_entry; KeyNavigation.tab: session_button
+		    KeyNavigation.backtab: pw_entry; KeyNavigation.tab: session
                 }
 
                 Item {
@@ -172,7 +172,7 @@ Rectangle {
                             source: "images/system_shutdown.png"
                             onClicked: sddm.powerOff()
 
-                            KeyNavigation.backtab: session_button; KeyNavigation.tab: reboot_button
+			    KeyNavigation.backtab: session; KeyNavigation.tab: reboot_button
                         }
 
                         ImageButton {
diff --git a/data/translations/ar.ts b/data/translations/ar.ts
index a8651d1..4bf1fd1 100644
--- a/data/translations/ar.ts
+++ b/data/translations/ar.ts
@@ -62,7 +62,7 @@
         <translation>أطفئ</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>اسم المستخدم</translation>
     </message>
     <message>
diff --git a/data/translations/bn.ts b/data/translations/bn.ts
index f2dff58..934a2aa 100644
--- a/data/translations/bn.ts
+++ b/data/translations/bn.ts
@@ -65,7 +65,7 @@
         <translation>শাটডাউন</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>ব্যবহারকারীর নাম</translation>
     </message>
     <message>
diff --git a/data/translations/ca.ts b/data/translations/ca.ts
index 916bf35..27cb437 100644
--- a/data/translations/ca.ts
+++ b/data/translations/ca.ts
@@ -62,7 +62,7 @@
         <translation>Apaga</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Usuari</translation>
     </message>
     <message>
diff --git a/data/translations/cs.ts b/data/translations/cs.ts
index 8d47f3f..1b8abff 100644
--- a/data/translations/cs.ts
+++ b/data/translations/cs.ts
@@ -62,7 +62,7 @@
         <translation>Vypnout</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Uživatelské jméno</translation>
     </message>
     <message>
diff --git a/data/translations/da.ts b/data/translations/da.ts
index 9bd2d59..a90f078 100644
--- a/data/translations/da.ts
+++ b/data/translations/da.ts
@@ -70,7 +70,7 @@
         <translation>Luk ned</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Brugernavn</translation>
     </message>
     <message>
diff --git a/data/translations/es.ts b/data/translations/es.ts
index 9f27a54..cea361e 100644
--- a/data/translations/es.ts
+++ b/data/translations/es.ts
@@ -62,7 +62,7 @@
         <translation>Apagar</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Usuario</translation>
     </message>
     <message>
diff --git a/data/translations/et.ts b/data/translations/et.ts
index ad3158d..4fbf811 100644
--- a/data/translations/et.ts
+++ b/data/translations/et.ts
@@ -62,7 +62,7 @@
         <translation>Seiska</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Kasutajanimi</translation>
     </message>
     <message>
diff --git a/data/translations/eu.ts b/data/translations/eu.ts
index a6b3fde..2b286bd 100644
--- a/data/translations/eu.ts
+++ b/data/translations/eu.ts
@@ -62,7 +62,7 @@
         <translation>Itzali</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Erabiltzaile izena</translation>
     </message>
     <message>
diff --git a/data/translations/fi.ts b/data/translations/fi.ts
index a4c3c01..07d3592 100644
--- a/data/translations/fi.ts
+++ b/data/translations/fi.ts
@@ -62,7 +62,7 @@
         <translation>Sammuta</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Käyttäjätunnus</translation>
     </message>
     <message>
diff --git a/data/translations/fr.ts b/data/translations/fr.ts
index 252e642..af06e15 100644
--- a/data/translations/fr.ts
+++ b/data/translations/fr.ts
@@ -70,7 +70,7 @@
         <translation>Éteindre</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Identifiant</translation>
     </message>
         <message>
diff --git a/data/translations/he.ts b/data/translations/he.ts
index a67f287..438265b 100644
--- a/data/translations/he.ts
+++ b/data/translations/he.ts
@@ -62,7 +62,7 @@
         <translation>כיבוי</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>שם משתמש</translation>
     </message>
     <message>
diff --git a/data/translations/hi_IN.ts b/data/translations/hi_IN.ts
index 4df7e97..498a02e 100644
--- a/data/translations/hi_IN.ts
+++ b/data/translations/hi_IN.ts
@@ -62,7 +62,7 @@
         <translation>बंद कीजिए</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>आपकी पहचान</translation>
     </message>
     <message>
diff --git a/data/translations/hsb.ts b/data/translations/hsb.ts
new file mode 100644
index 0000000..c296d8b
--- /dev/null
+++ b/data/translations/hsb.ts
@@ -0,0 +1,117 @@
+<?xml version='1.0' encoding='utf-8'?>
+<!DOCTYPE TS>
+<TS version="2.1" language="hsb">
+<context>
+    <name>PictureBox</name>
+    <message>
+        <source>Press to login</source>
+        <translation>Klikńće tu, zo byšće so přizjewili</translation>
+    </message>
+</context>
+<context>
+    <name>QObject</name>
+    <message>
+        <source>%1 (Wayland)</source>
+        <translation>%1 (Wayland)</translation>
+    </message>
+</context>
+<context>
+    <name>TextConstants</name>
+    <message>
+        <source>Welcome to %1</source>
+        <translation>Witajće na %1</translation>
+    </message>
+    <message>
+        <source>Warning, Caps Lock is ON!</source>
+        <translation>Kedźbu, wulkopisanje je zaswěćene!</translation>
+    </message>
+    <message>
+        <source>Layout</source>
+        <translation>Layout</translation>
+    </message>
+    <message>
+        <source>Login</source>
+        <translation>So přizjewić</translation>
+    </message>
+    <message>
+        <source>Login failed</source>
+        <translation>Přizjewjenje njeje so poradźiło</translation>
+    </message>
+    <message>
+        <source>Login succeeded</source>
+        <translation>Přizjewjenje bě wuspěšne</translation>
+    </message>
+    <message>
+        <source>Password</source>
+        <translation>Hesło</translation>
+    </message>
+    <message>
+        <source>Enter your username and password</source>
+        <translation>Prošu zapodajće wužiwarske mjeno a hesło</translation>
+    </message>
+    <message>
+        <source>Reboot</source>
+        <translation>Znowa startować</translation>
+    </message>
+    <message>
+        <source>Suspend</source>
+        <translation>Spinkać</translation>
+    </message>
+    <message>
+        <source>Hibernate</source>
+        <translation>Zymski spar</translation>
+    </message>
+    <message>
+        <source>Session</source>
+        <translation>Posedźenje</translation>
+    </message>
+    <message>
+        <source>Shutdown</source>
+        <translation>Hasnyć</translation>
+    </message>
+    <message>
+        <source>Username</source>
+        <translation>Wužiwarske mjeno</translation>
+    </message>
+    <message>
+        <source>Enter your username</source>
+        <translation>Zapodajće swoje wužiwarske mjeno</translation>
+    </message>
+    <message>
+        <source>Enter your password</source>
+        <translation>Zapodajće swoje hesło</translation>
+    </message>
+    <message>
+        <source>Select your user and enter password</source>
+        <translation>Wužiwarja wubrać a hesło zapodać</translation>
+    </message>
+    <message>
+        <source>Show password</source>
+        <translation>Hesło pokazać</translation>
+    </message>
+    <message>
+        <source>Hide password</source>
+        <translation>Hesło chować</translation>
+    </message>
+    <message>
+        <source>Please enter a password!</source>
+        <translation>Prošu zapodajće hesło!</translation>
+    </message>
+    <message>
+        <source>Change password</source>
+        <translation>Hesło změnić</translation>
+    </message>
+    <message>
+        <source>Password:</source>
+        <translation>Hesło:</translation>
+    </message>
+    <message>
+        <source>Password change aborted because maximum tries reached</source>
+        <translation>Změna hesła přetorhnjena (přewjele pospytow)</translation>
+    </message>
+    <message>
+        <source>New password change round! Please input current password again!</source>
+        <translation>Přichodny pospyt změny hesła! Prošu zapodajće tuchwilne hesło znowa!</translation>
+    </message>
+</context>
+</TS>
diff --git a/data/translations/hu.ts b/data/translations/hu.ts
index f1cc9e3..cdd41c5 100644
--- a/data/translations/hu.ts
+++ b/data/translations/hu.ts
@@ -62,7 +62,7 @@
         <translation>Leállítás</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Felhasználónév</translation>
     </message>
     <message>
diff --git a/data/translations/ie.ts b/data/translations/ie.ts
index 856824a..80eb25d 100644
--- a/data/translations/ie.ts
+++ b/data/translations/ie.ts
@@ -60,7 +60,7 @@
     </message>
     <message>
         <location filename="TextConstants.qml" line="43"/>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Usator</translation>
     </message>
     <message>
diff --git a/data/translations/is.ts b/data/translations/is.ts
index 6baac7c..11edff9 100644
--- a/data/translations/is.ts
+++ b/data/translations/is.ts
@@ -62,7 +62,7 @@
         <translation>Slökkva</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Notandanafn</translation>
     </message>
     <message>
diff --git a/data/translations/it.ts b/data/translations/it.ts
index 3d4c077..a5e1b25 100644
--- a/data/translations/it.ts
+++ b/data/translations/it.ts
@@ -62,7 +62,7 @@
         <translation>Spegni</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Nome utente</translation>
     </message>
     <message>
diff --git a/data/translations/ja.ts b/data/translations/ja.ts
index 4c90a65..2bd0bc0 100644
--- a/data/translations/ja.ts
+++ b/data/translations/ja.ts
@@ -62,7 +62,7 @@
         <translation>シャットダウン</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>ユーザ名</translation>
     </message>
     <message>
diff --git a/data/translations/kk.ts b/data/translations/kk.ts
index a1eb5f4..5c56a77 100644
--- a/data/translations/kk.ts
+++ b/data/translations/kk.ts
@@ -62,7 +62,7 @@
         <translation>Сөндіру</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Пайдаланушы аты</translation>
     </message>
     <message>
diff --git a/data/translations/ko.ts b/data/translations/ko.ts
index d491738..5ee5bf1 100644
--- a/data/translations/ko.ts
+++ b/data/translations/ko.ts
@@ -65,10 +65,6 @@
         <source>Shutdown</source>
         <translation>컴퓨터 끄기</translation>
     </message>
-    <message>
-        <source>User name</source>
-        <translation>사용자 이름</translation>
-    </message>
     <message>
         <source>Welcome to %1</source>
         <translation>%1에 오신 것을 환영합니다</translation>
diff --git a/data/translations/lt.ts b/data/translations/lt.ts
index e674de0..2333eed 100644
--- a/data/translations/lt.ts
+++ b/data/translations/lt.ts
@@ -53,6 +53,14 @@
         <source>Reboot</source>
         <translation>Paleisti iš naujo</translation>
     </message>
+    <message>
+        <source>Suspend</source>
+        <translation>Pristabdyti</translation>
+    </message>
+    <message>
+        <source>Hibernate</source>
+        <translation>Užmigdyti</translation>
+    </message>
     <message>
         <source>Session</source>
         <translation>Seansas</translation>
@@ -62,12 +70,48 @@
         <translation>Išjungti</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Naudotojo vardas</translation>
     </message>
+    <message>
+        <source>Enter your username</source>
+        <translation>Įveskite savo naudotojo vardą</translation>
+    </message>
+    <message>
+        <source>Enter your password</source>
+        <translation>Įveskite savo slaptažodį</translation>
+    </message>
     <message>
         <source>Select your user and enter password</source>
         <translation>Pasirinkite savo naudotoją ir įveskite slaptažodį</translation>
     </message>
+    <message>
+        <source>Show password</source>
+        <translation>Rodyti slaptažodį</translation>
+    </message>
+    <message>
+        <source>Hide password</source>
+        <translation>Slėpti slaptažodį</translation>
+    </message>
+    <message>
+        <source>Please enter a password!</source>
+        <translation>Įveskite slaptažodį!</translation>
+    </message>
+    <message>
+        <source>Change password</source>
+        <translation>Keisti slaptažodį</translation>
+    </message>
+    <message>
+        <source>Password:</source>
+        <translation>Slaptažodis:</translation>
+    </message>
+    <message>
+        <source>Password change aborted because maximum tries reached</source>
+        <translation>Slaptažodžio keitimas nutrauktas, nes pasiektas didžiausias bandymų skaičius</translation>
+    </message>
+    <message>
+        <source>New password change round! Please input current password again!</source>
+        <translation>Dar kartą įveskite dabartinį slaptažodį!</translation>
+    </message>
 </context>
 </TS>
diff --git a/data/translations/lv.ts b/data/translations/lv.ts
index 05721e9..67823cd 100644
--- a/data/translations/lv.ts
+++ b/data/translations/lv.ts
@@ -62,7 +62,7 @@
         <translation>Izslēgt</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Lietotāja vārds</translation>
     </message>
     <message>
diff --git a/data/translations/nb.ts b/data/translations/nb.ts
index 56a6116..3d3c694 100644
--- a/data/translations/nb.ts
+++ b/data/translations/nb.ts
@@ -4,7 +4,6 @@
 <context>
     <name>PictureBox</name>
     <message>
-        <location filename="../../components/2.0/PictureBox.qml" line="123"/>
         <source>Press to login</source>
         <translation>Trykk for å logge inn</translation>
     </message>
@@ -12,7 +11,6 @@
 <context>
     <name>QObject</name>
     <message>
-        <location filename="../../src/common/Session.cpp" line="166"/>
         <source>%1 (Wayland)</source>
         <translation>%1 (Wayland)</translation>
     </message>
@@ -20,69 +18,100 @@
 <context>
     <name>TextConstants</name>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="28"/>
+        <source>Welcome to %1</source>
+        <translation>Velkommen til %1</translation>
+    </message>
+    <message>
         <source>Warning, Caps Lock is ON!</source>
         <translation>Advarsel: «Caps Lock» står på!</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="29"/>
         <source>Layout</source>
         <translation>Tastatur</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="30"/>
         <source>Login</source>
         <translation>Logg inn</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="31"/>
         <source>Login failed</source>
-        <translation>Klarte ikke logge inn</translation>
+        <translation>Innlogging feilet</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="32"/>
         <source>Login succeeded</source>
-        <translation>Innlogget</translation>
+        <translation>Innlogging lyktes</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="33"/>
         <source>Password</source>
         <translation>Passord</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="34"/>
         <source>Enter your username and password</source>
-        <translation>Skriv inn brukernavn og passord</translation>
+        <translation>Skriv inn ditt brukernavn og passord</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="35"/>
-        <source>Select your user and enter password</source>
-        <translation>Velg bruker og skriv inn passord</translation>
+        <source>Reboot</source>
+        <translation>Omstart</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="36"/>
-        <source>Reboot</source>
-        <translation>Start på nytt</translation>
+        <source>Suspend</source>
+        <translation>Hvile</translation>
+    </message>
+    <message>
+        <source>Hibernate</source>
+        <translation>Dvale</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="37"/>
         <source>Session</source>
         <translation>Økt</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="38"/>
         <source>Shutdown</source>
         <translation>Slå av</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="39"/>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Brukernavn</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="40"/>
-        <source>Welcome to %1</source>
-        <translation>Velkommen til %1</translation>
+        <source>Enter your username</source>
+        <translation>Skriv inn ditt brukernavn</translation>
+    </message>
+    <message>
+        <source>Enter your password</source>
+        <translation>Skriv inn ditt passord</translation>
+    </message>
+    <message>
+        <source>Select your user and enter password</source>
+        <translation>Velg bruker og skriv inn passord</translation>
+    </message>
+    <message>
+        <source>Show password</source>
+        <translation>Vis passord</translation>
+    </message>
+    <message>
+        <source>Hide password</source>
+        <translation>Skjul passord</translation>
+    </message>
+    <message>
+        <source>Please enter a password!</source>
+        <translation>Vennligst skriv inn et passord!</translation>
+    </message>
+    <message>
+        <source>Change password</source>
+        <translation>Endre passord</translation>
+    </message>
+    <message>
+        <source>Unregistered user</source>
+        <translation>Ugyldig bruker</translation>
+    </message>
+    <message>
+        <source>Password change aborted because maximum tries reached</source>
+        <translation>Endring av passord ble avbrutt da høyeste antall forsøk er nådd</translation>
+    </message>
+    <message>
+        <source>New password change round! Please input current password again!</source>
+        <translation>Ny runde for ending av passord! Vennligst skriv inn det nåværende passordet igjen!</translation>
     </message>
 </context>
 </TS>
diff --git a/data/translations/nl.ts b/data/translations/nl.ts
index 1e43949..35c250a 100644
--- a/data/translations/nl.ts
+++ b/data/translations/nl.ts
@@ -62,7 +62,7 @@
         <translation>Uitschakelen</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Gebruikersnaam</translation>
     </message>
     <message>
diff --git a/data/translations/nn.ts b/data/translations/nn.ts
index 729e443..29d8523 100644
--- a/data/translations/nn.ts
+++ b/data/translations/nn.ts
@@ -4,7 +4,6 @@
 <context>
     <name>PictureBox</name>
     <message>
-        <location filename="../../components/2.0/PictureBox.qml" line="123"/>
         <source>Press to login</source>
         <translation>Trykk for å logga inn</translation>
     </message>
@@ -12,7 +11,6 @@
 <context>
     <name>QObject</name>
     <message>
-        <location filename="../../src/common/Session.cpp" line="166"/>
         <source>%1 (Wayland)</source>
         <translation>%1 (Wayland)</translation>
     </message>
@@ -20,69 +18,100 @@
 <context>
     <name>TextConstants</name>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="28"/>
+        <source>Welcome to %1</source>
+        <translation>Velkommen til %1</translation>
+    </message>
+    <message>
         <source>Warning, Caps Lock is ON!</source>
         <translation>Åtvaring: «Caps Lock» står på!</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="29"/>
         <source>Layout</source>
         <translation>Tastatur</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="30"/>
         <source>Login</source>
         <translation>Logg inn</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="31"/>
         <source>Login failed</source>
         <translation>Klarte ikkje logga inn</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="32"/>
         <source>Login succeeded</source>
         <translation>Logga inn</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="33"/>
         <source>Password</source>
         <translation>Passord</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="34"/>
-        <source>Enter your username and password</source>
-        <translation>Skriv inn brukarnamn og passord</translation>
+        <source>Enter your username</source>
+        <translation>Skriv inn brukarnamn</translation>
+    </message>
+    <message>
+        <source>Enter your password</source>
+        <translation>Skriv inn passord</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="35"/>
         <source>Select your user and enter password</source>
         <translation>Vel brukar og skriv inn passord</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="36"/>
         <source>Reboot</source>
         <translation>Start på nytt</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="37"/>
         <source>Session</source>
         <translation>Økt</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="38"/>
         <source>Shutdown</source>
         <translation>Slå av</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="39"/>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Brukarnamn</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="40"/>
-        <source>Welcome to %1</source>
-        <translation>Velkommen til %1</translation>
+        <source>Enter your username</source>
+        <translation>Skriv inn brukarnamn</translation>
+    </message>
+    <message>
+        <source>Enter your password</source>
+        <translation>Skriv inn passord</translation>
+    </message>
+    <message>
+        <source>Select your user and enter password</source>
+        <translation>Vel brukar og skriv inn passord</translation>
+    </message>
+    <message>
+        <source>Show password</source>
+        <translation>Vis passord</translation>
+    </message>
+    <message>
+        <source>Hide password</source>
+        <translation>Skjul passord</translation>
+    </message>
+    <message>
+        <source>Please enter a password!</source>
+        <translation>Ver vennleg og skriv inn eit passord!</translation>
+    </message>
+    <message>
+        <source>Change password</source>
+        <translation>Endre passord</translation>
+    </message>
+    <message>
+        <source>Unregistered user</source>
+        <translation>Ugyldig brukar</translation>
+    </message>
+    <message>
+        <source>Password change aborted because maximum tries reached</source>
+        <translation>Endring av passord vart avbrotne då høgaste talet på forsøk er nådd</translation>
+    </message>
+    <message>
+        <source>New password change round! Please input current password again!</source>
+        <translation>Ny runde for ending av passord! Ver vennleg og skriv inn det noverande passordet igjen!</translation>
     </message>
 </context>
 </TS>
diff --git a/data/translations/oc.ts b/data/translations/oc.ts
index 3826d94..0823beb 100644
--- a/data/translations/oc.ts
+++ b/data/translations/oc.ts
@@ -62,7 +62,7 @@
         <translation>Atudar</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Nom d’utilizaire</translation>
     </message>
     <message>
diff --git a/data/translations/pl.ts b/data/translations/pl.ts
index 58ae76a..b0b728d 100644
--- a/data/translations/pl.ts
+++ b/data/translations/pl.ts
@@ -78,7 +78,7 @@
         <translation>Zahibernuj</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Nazwa użytkownika</translation>
     </message>
     <message>
diff --git a/data/translations/pt_BR.ts b/data/translations/pt_BR.ts
index 40b03c2..f18526e 100644
--- a/data/translations/pt_BR.ts
+++ b/data/translations/pt_BR.ts
@@ -62,7 +62,7 @@
         <translation>Desligar</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Usuário</translation>
     </message>
     <message>
diff --git a/data/translations/pt_PT.ts b/data/translations/pt_PT.ts
index bc2c5c8..403dc92 100644
--- a/data/translations/pt_PT.ts
+++ b/data/translations/pt_PT.ts
@@ -62,7 +62,7 @@
         <translation>Desligar</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Utilizador</translation>
     </message>
     <message>
diff --git a/data/translations/ro.ts b/data/translations/ro.ts
index 96883f5..062a43e 100644
--- a/data/translations/ro.ts
+++ b/data/translations/ro.ts
@@ -62,7 +62,7 @@
         <translation>Oprește</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Nume de utilizator</translation>
     </message>
     <message>
diff --git a/data/translations/sk.ts b/data/translations/sk.ts
index efc7eb0..395abc4 100644
--- a/data/translations/sk.ts
+++ b/data/translations/sk.ts
@@ -62,7 +62,7 @@
         <translation>Vypnúť</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Užívateľské meno</translation>
     </message>
     <message>
diff --git a/data/translations/sr.ts b/data/translations/sr.ts
index 994eab9..2c81253 100644
--- a/data/translations/sr.ts
+++ b/data/translations/sr.ts
@@ -62,7 +62,7 @@
         <translation>Угаси</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Корисничко име</translation>
     </message>
     <message>
diff --git a/data/translations/sr@ijekavian.ts b/data/translations/sr@ijekavian.ts
index d6558dc..ad73ecc 100644
--- a/data/translations/sr@ijekavian.ts
+++ b/data/translations/sr@ijekavian.ts
@@ -62,7 +62,7 @@
         <translation>Угаси</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Корисничко име</translation>
     </message>
     <message>
diff --git a/data/translations/sr@ijekavianlatin.ts b/data/translations/sr@ijekavianlatin.ts
index 73ea97b..80b8cc2 100644
--- a/data/translations/sr@ijekavianlatin.ts
+++ b/data/translations/sr@ijekavianlatin.ts
@@ -62,7 +62,7 @@
         <translation>Ugasi</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Korisničko ime</translation>
     </message>
     <message>
diff --git a/data/translations/sr@latin.ts b/data/translations/sr@latin.ts
index 221f669..fc540c3 100644
--- a/data/translations/sr@latin.ts
+++ b/data/translations/sr@latin.ts
@@ -62,7 +62,7 @@
         <translation>Ugasi</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Korisničko ime</translation>
     </message>
     <message>
diff --git a/data/translations/sv.ts b/data/translations/sv.ts
index 319ff23..3421a71 100644
--- a/data/translations/sv.ts
+++ b/data/translations/sv.ts
@@ -1,10 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!DOCTYPE TS>
-<TS version="2.1" language="nn">
+<TS version="2.1" language="sv">
 <context>
     <name>PictureBox</name>
     <message>
-        <location filename="../../components/2.0/PictureBox.qml" line="123"/>
         <source>Press to login</source>
         <translation>Tryck för att logga in</translation>
     </message>
@@ -12,7 +11,6 @@
 <context>
     <name>QObject</name>
     <message>
-        <location filename="../../src/common/Session.cpp" line="166"/>
         <source>%1 (Wayland)</source>
         <translation>%1 (Wayland)</translation>
     </message>
@@ -20,69 +18,101 @@
 <context>
     <name>TextConstants</name>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="28"/>
+        <source>Welcome to %1</source>
+        <translation>Välkommen till %1</translation>
+    </message>
+    <message>
         <source>Warning, Caps Lock is ON!</source>
         <translation>Varning, «Caps Lock» är på!</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="29"/>
         <source>Layout</source>
         <translation>Tangentbordslayout</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="30"/>
         <source>Login</source>
         <translation>Logga in</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="31"/>
         <source>Login failed</source>
         <translation>Inloggningen misslyckades</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="32"/>
         <source>Login succeeded</source>
         <translation>Inloggningen lyckades</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="33"/>
         <source>Password</source>
         <translation>Lösenord</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="34"/>
         <source>Enter your username and password</source>
         <translation>Fyll i ditt användarnamn och lösenord</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="35"/>
-        <source>Select your user and enter password</source>
-        <translation>Välj din användare och ange lösenord</translation>
-    </message>
-    <message>
-        <location filename="../../components/common/TextConstants.qml" line="36"/>
         <source>Reboot</source>
         <translation>Starta om</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="37"/>
+        <source>Suspend</source>
+        <translation>Vänteläge</translation>
+    </message>
+    <message>
+        <source>Hibernate</source>
+        <translation>Viloläge</translation>
+    </message>
+    <message>
         <source>Session</source>
         <translation>Session</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="38"/>
         <source>Shutdown</source>
         <translation>Stäng av</translation>
     </message>
     <message>
         <location filename="../../components/common/TextConstants.qml" line="39"/>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Användarnamn</translation>
     </message>
     <message>
-        <location filename="../../components/common/TextConstants.qml" line="40"/>
-        <source>Welcome to %1</source>
-        <translation>Välkommen till %1</translation>
+        <source>Enter your username</source>
+        <translation>Fyll i ditt användarnamn</translation>
+    </message>
+    <message>
+        <source>Enter your password</source>
+        <translation>Fyll i ditt lösenord</translation>
+    </message>
+    <message>
+        <source>Select your user and enter password</source>
+        <translation>Välj användarnamn och skriv in lösenord</translation>
+    </message>
+    <message>
+        <source>Show password</source>
+        <translation>Visa lösenord</translation>
+    </message>
+    <message>
+        <source>Hide password</source>
+        <translation>Dölj lösenord</translation>
+    </message>
+    <message>
+        <source>Please enter a password!</source>
+        <translation>Fyll i lösenord!</translation>
+    </message>
+    <message>
+        <source>Change password</source>
+        <translation>Ändra lösenord</translation>
+    </message>
+    <message>
+        <source>Unregistered user</source>
+        <translation>Ogiltig användarnamn</translation>
+    </message>
+    <message>
+        <source>Password change aborted because maximum tries reached</source>
+        <translation>Lösenordsbyte avbröts eftersom maximalt antal försök har uppnåtts</translation>
+    </message>
+    <message>
+        <source>New password change round! Please input current password again!</source>
+        <translation>Nytt varv för lösenordsbyte! Skriv in nuvarande lösenord igen!</translation>
     </message>
 </context>
 </TS>
diff --git a/data/translations/tr.ts b/data/translations/tr.ts
index dc52078..16924b9 100644
--- a/data/translations/tr.ts
+++ b/data/translations/tr.ts
@@ -5,14 +5,14 @@
     <name>PictureBox</name>
     <message>
         <source>Press to login</source>
-        <translation type="unfinished"></translation>
+        <translation>Giriş yapmak için tıklayın</translation>
     </message>
 </context>
 <context>
     <name>QObject</name>
     <message>
         <source>%1 (Wayland)</source>
-        <translation type="unfinished"></translation>
+        <translation>%1 (Wayland)</translation>
     </message>
 </context>
 <context>
@@ -62,7 +62,7 @@
         <translation>Kapat</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Kullanıcı adı</translation>
     </message>
     <message>
diff --git a/data/translations/uk.ts b/data/translations/uk.ts
index bb14d69..23d8e39 100644
--- a/data/translations/uk.ts
+++ b/data/translations/uk.ts
@@ -48,7 +48,7 @@
         <translation>Вимкнути</translation>
     </message>
     <message>
-        <source>User name</source>
+        <source>Username</source>
         <translation>Ім'я користувача</translation>
     </message>
     <message>
diff --git a/services/CMakeLists.txt b/services/CMakeLists.txt
index fbf7608..5032f33 100644
--- a/services/CMakeLists.txt
+++ b/services/CMakeLists.txt
@@ -1,3 +1,4 @@
+
 if(SYSTEMD_FOUND)
     configure_file("${CMAKE_CURRENT_SOURCE_DIR}/sddm.service.in" "${CMAKE_CURRENT_BINARY_DIR}/sddm.service")
     install(FILES "${CMAKE_CURRENT_BINARY_DIR}/sddm.service" DESTINATION "${SYSTEMD_SYSTEM_UNIT_DIR}")
@@ -10,6 +11,17 @@ else()
 endif()
 configure_file("${CMAKE_CURRENT_SOURCE_DIR}/sddm-greeter.pam.in" "${CMAKE_CURRENT_BINARY_DIR}/sddm-greeter.pam")
 
-install(FILES sddm.pam DESTINATION ${CMAKE_INSTALL_FULL_SYSCONFDIR}/pam.d RENAME sddm)
-install(FILES sddm-autologin.pam DESTINATION ${CMAKE_INSTALL_FULL_SYSCONFDIR}/pam.d RENAME sddm-autologin)
-install(FILES "${CMAKE_CURRENT_BINARY_DIR}/sddm-greeter.pam" DESTINATION ${CMAKE_INSTALL_FULL_SYSCONFDIR}/pam.d RENAME sddm-greeter)
+if(EXISTS "/etc/debian_version")
+    install(FILES debian.sddm-autologin.pam DESTINATION ${CMAKE_INSTALL_FULL_SYSCONFDIR}/pam.d RENAME sddm-autologin)
+    install(FILES debian.sddm-greeter.pam DESTINATION ${CMAKE_INSTALL_FULL_SYSCONFDIR}/pam.d RENAME sddm-greeter)
+    install(FILES debian.sddm.pam DESTINATION ${CMAKE_INSTALL_FULL_SYSCONFDIR}/pam.d RENAME sddm)
+else()
+    if(HAVE_PAM_FAILLOCK)
+        install(FILES sddm-autologin.pam DESTINATION ${CMAKE_INSTALL_FULL_SYSCONFDIR}/pam.d RENAME sddm-autologin)
+    else()
+        install(FILES sddm-autologin-tally2.pam DESTINATION ${CMAKE_INSTALL_FULL_SYSCONFDIR}/pam.d RENAME sddm-autologin)
+    endif()
+
+    install(FILES sddm.pam DESTINATION ${CMAKE_INSTALL_FULL_SYSCONFDIR}/pam.d RENAME sddm)
+    install(FILES "${CMAKE_CURRENT_BINARY_DIR}/sddm-greeter.pam" DESTINATION ${CMAKE_INSTALL_FULL_SYSCONFDIR}/pam.d RENAME sddm-greeter)
+endif()
diff --git a/services/debian.sddm-autologin.pam b/services/debian.sddm-autologin.pam
new file mode 100644
index 0000000..d595682
--- /dev/null
+++ b/services/debian.sddm-autologin.pam
@@ -0,0 +1,32 @@
+#%PAM-1.0
+
+# Block login if they are globally disabled
+auth    requisite       pam_nologin.so
+auth    required        pam_permit.so
+
+@include common-account
+
+# SELinux needs to be the first session rule.  This ensures that any
+# lingering context has been cleared.  Without this it is possible that a
+# module could execute code in the wrong domain.
+session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so close
+# Create a new session keyring.
+session optional        pam_keyinit.so force revoke
+session required        pam_limits.so
+session required        pam_loginuid.so
+@include common-session
+# SELinux needs to intervene at login time to ensure that the process starts
+# in the proper default security context.  Only sessions which are intended
+# to run in the user's context should be run after this.
+session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so open
+
+@include common-password
+
+# From the pam_env man page
+# Since setting of PAM environment variables can have side effects to other modules, this module should be the last one on the stack.
+
+# Load environment from /etc/environment
+session required        pam_env.so
+
+# Load environment from /etc/default/locale
+session required        pam_env.so envfile=/etc/default/locale
diff --git a/services/debian.sddm-greeter.pam b/services/debian.sddm-greeter.pam
new file mode 100644
index 0000000..78aed41
--- /dev/null
+++ b/services/debian.sddm-greeter.pam
@@ -0,0 +1,31 @@
+#%PAM-1.0
+
+auth    required        pam_permit.so
+
+@include common-account
+
+# SELinux needs to be the first session rule.  This ensures that any
+# lingering context has been cleared.  Without this it is possible that a
+# module could execute code in the wrong domain.
+session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so close
+# Create a new session keyring.
+session optional        pam_keyinit.so force revoke
+session required        pam_limits.so
+session required        pam_loginuid.so
+@include common-session
+# SELinux needs to intervene at login time to ensure that the process starts
+# in the proper default security context.  Only sessions which are intended
+# to run in the user's context should be run after this.
+session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so open
+
+# Can't change password
+password        required pam_deny.so
+
+# From the pam_env man page
+# Since setting of PAM environment variables can have side effects to other modules, this module should be the last one on the stack.
+
+# Load environment from /etc/environment
+session required        pam_env.so
+
+# Load environment from /etc/default/locale
+session required        pam_env.so envfile=/etc/default/locale
diff --git a/services/debian.sddm.pam b/services/debian.sddm.pam
new file mode 100644
index 0000000..de7fd79
--- /dev/null
+++ b/services/debian.sddm.pam
@@ -0,0 +1,40 @@
+#%PAM-1.0
+
+# Block login if they are globally disabled
+auth    requisite       pam_nologin.so
+auth    required        pam_succeed_if.so user != root quiet_success
+
+# auth    sufficient      pam_succeed_if.so user ingroup nopasswdlogin
+@include common-auth
+# gnome_keyring breaks QProcess
+-auth   optional        pam_gnome_keyring.so
+-auth   optional        pam_kwallet5.so
+
+@include common-account
+
+# SELinux needs to be the first session rule.  This ensures that any
+# lingering context has been cleared.  Without this it is possible that a
+# module could execute code in the wrong domain.
+session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so close
+# Create a new session keyring.
+session optional        pam_keyinit.so force revoke
+session required        pam_limits.so
+session required        pam_loginuid.so
+@include common-session
+# SELinux needs to intervene at login time to ensure that the process starts
+# in the proper default security context.  Only sessions which are intended
+# to run in the user's context should be run after this.
+session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so open
+-session optional       pam_gnome_keyring.so auto_start
+-session optional       pam_kwallet5.so auto_start
+
+@include common-password
+
+# From the pam_env man page
+# Since setting of PAM environment variables can have side effects to other modules, this module should be the last one on the stack.
+
+# Load environment from /etc/environment
+session required        pam_env.so
+
+# Load environment from /etc/default/locale and ~/.pam_environment
+session required        pam_env.so envfile=/etc/default/locale user_readenv=1
diff --git a/services/sddm-autologin-tally2.pam b/services/sddm-autologin-tally2.pam
new file mode 100755
index 0000000..99729bc
--- /dev/null
+++ b/services/sddm-autologin-tally2.pam
@@ -0,0 +1,13 @@
+#%PAM-1.0
+auth        required    pam_env.so
+auth        required    pam_tally2.so file=/var/log/tallylog onerr=succeed
+auth        required    pam_shells.so
+auth        required    pam_nologin.so
+auth        required    pam_permit.so
+-auth       optional    pam_gnome_keyring.so
+-auth       optional    pam_kwallet5.so
+account     include     system-local-login
+password    include     system-local-login
+session     include     system-local-login
+-session    optional    pam_gnome_keyring.so auto_start
+-session    optional    pam_kwallet5.so auto_start
diff --git a/services/sddm-autologin.pam b/services/sddm-autologin.pam
index 99729bc..b42991e 100755
--- a/services/sddm-autologin.pam
+++ b/services/sddm-autologin.pam
@@ -1,6 +1,6 @@
 #%PAM-1.0
 auth        required    pam_env.so
-auth        required    pam_tally2.so file=/var/log/tallylog onerr=succeed
+auth        required    pam_faillock.so preauth
 auth        required    pam_shells.so
 auth        required    pam_nologin.so
 auth        required    pam_permit.so
diff --git a/services/sddm.service.in b/services/sddm.service.in
index 0335685..d787019 100644
--- a/services/sddm.service.in
+++ b/services/sddm.service.in
@@ -3,6 +3,7 @@ Description=Simple Desktop Display Manager
 Documentation=man:sddm(1) man:sddm.conf(5)
 Conflicts=getty@tty1.service
 After=systemd-user-sessions.service getty@tty1.service plymouth-quit.service systemd-logind.service
+PartOf=graphical.target
 StartLimitIntervalSec=30
 StartLimitBurst=2
 
diff --git a/src/auth/Auth.cpp b/src/auth/Auth.cpp
index caca314..98e145e 100644
--- a/src/auth/Auth.cpp
+++ b/src/auth/Auth.cpp
@@ -62,6 +62,7 @@ namespace SDDM {
         AuthRequest *request { nullptr };
         QProcess *child { nullptr };
         QLocalSocket *socket { nullptr };
+        QString displayServerCmd;
         QString sessionPath { };
         QString user { };
         QString cookie { };
@@ -132,7 +133,7 @@ namespace SDDM {
             env.insert(QStringLiteral("LANG"), QStringLiteral("C"));
         child->setProcessEnvironment(env);
         connect(child, QOverload<int,QProcess::ExitStatus>::of(&QProcess::finished), this, &Auth::Private::childExited);
-        connect(child, QOverload<QProcess::ProcessError>::of(&QProcess::error), this, &Auth::Private::childError);
+        connect(child, &QProcess::errorOccurred, this, &Auth::Private::childError);
         connect(request, &AuthRequest::finished, this, &Auth::Private::requestFinished);
         connect(request, &AuthRequest::promptsChanged, parent, &Auth::requestChanged);
     }
@@ -199,6 +200,15 @@ namespace SDDM {
                 str.send();
                 break;
             }
+        case DISPLAY_SERVER_STARTED: {
+                QString displayName;
+                str >> displayName;
+                Q_EMIT auth->displayServerReady(displayName);
+                str.reset();
+                str << DISPLAY_SERVER_STARTED;
+                str.send();
+                break;
+            }
             default: {
                 Q_EMIT auth->error(QStringLiteral("Auth: Unexpected value received: %1").arg(m), ERROR_INTERNAL);
             }
@@ -207,7 +217,9 @@ namespace SDDM {
 
     void Auth::Private::childExited(int exitCode, QProcess::ExitStatus exitStatus) {
         if (exitStatus != QProcess::NormalExit) {
-            qWarning("Auth: sddm-helper crashed (exit code %d)", exitCode);
+            qWarning("Auth: sddm-helper (%s) crashed (exit code %d)",
+                     qPrintable(child->arguments().join(QLatin1Char(' '))),
+                     HelperExitStatus(exitStatus));
             Q_EMIT qobject_cast<Auth*>(parent())->error(child->errorString(), ERROR_INTERNAL);
         }
 
@@ -252,8 +264,8 @@ namespace SDDM {
     }
 
     void Auth::registerTypes() {
-        qmlRegisterType<AuthPrompt>();
-        qmlRegisterType<AuthRequest>();
+        qmlRegisterAnonymousType<AuthPrompt>("Auth", 1);
+        qmlRegisterAnonymousType<AuthRequest>("Auth", 1);
         qmlRegisterType<Auth>("Auth", 1, 0, "Auth");
     }
 
@@ -327,6 +339,14 @@ namespace SDDM {
         }
     }
 
+    void Auth::setDisplayServerCommand(const QString &command)
+    {
+        if (d->displayServerCmd != command) {
+            d->displayServerCmd = command;
+            Q_EMIT displayServerCommandChanged();
+        }
+    }
+
     void Auth::setSession(const QString& path) {
         if (path != d->sessionPath) {
             d->sessionPath = path;
@@ -354,10 +374,20 @@ namespace SDDM {
             args << QStringLiteral("--user") << d->user;
         if (d->autologin)
             args << QStringLiteral("--autologin");
+        if (!d->displayServerCmd.isEmpty())
+            args << QStringLiteral("--display-server") << d->displayServerCmd;
         if (d->greeter)
             args << QStringLiteral("--greeter");
         d->child->start(QStringLiteral("%1/sddm-helper").arg(QStringLiteral(LIBEXEC_INSTALL_DIR)), args);
     }
+
+    void Auth::stop() {
+        d->child->terminate();
+
+        // wait for finished
+        if (!d->child->waitForFinished(5000))
+            d->child->kill();
+    }
 }
 
 #include "Auth.moc"
diff --git a/src/auth/Auth.h b/src/auth/Auth.h
index 87f5f44..830b91e 100644
--- a/src/auth/Auth.h
+++ b/src/auth/Auth.h
@@ -69,6 +69,7 @@ namespace SDDM {
             INFO_PASS_CHANGE_REQUIRED,
             _INFO_LAST
         };
+        Q_ENUM(Info)
 
         enum Error {
             ERROR_NONE = 0,
@@ -77,6 +78,7 @@ namespace SDDM {
             ERROR_INTERNAL,
             _ERROR_LAST
         };
+        Q_ENUM(Error)
 
         enum HelperExitStatus {
             HELPER_SUCCESS = 0,
@@ -84,6 +86,7 @@ namespace SDDM {
             HELPER_SESSION_ERROR,
             HELPER_OTHER_ERROR
         };
+        Q_ENUM(HelperExitStatus)
 
         static void registerTypes();
 
@@ -139,6 +142,12 @@ namespace SDDM {
         */
         void setUser(const QString &user);
 
+        /**
+         * Set the display server command to be started before the greeter.
+         * @param command Command of the display server to be started
+         */
+        void setDisplayServerCommand(const QString &command);
+
         /**
         * Set the session to be started after authenticating.
         * @param path Path of the session executable to be started
@@ -157,12 +166,18 @@ namespace SDDM {
         */
         void start();
 
+        /**
+         * Indicates that we do not need the process anymore.
+         */
+        void stop();
+
     Q_SIGNALS:
         void autologinChanged();
         void greeterChanged();
         void verboseChanged();
         void cookieChanged();
         void userChanged();
+        void displayServerCommandChanged();
         void sessionChanged();
         void requestChanged();
 
@@ -184,6 +199,13 @@ namespace SDDM {
         */
         void sessionStarted(bool success);
 
+        /**
+         * Emitted when the display server is ready.
+         *
+         * @param displayName display name
+         */
+        void displayServerReady(const QString &displayName);
+
         /**
         * Emitted when the helper quits, either after authentication or when the session ends.
         * Or, when something goes wrong.
diff --git a/src/auth/AuthMessages.h b/src/auth/AuthMessages.h
index 3bc97b6..6aea748 100644
--- a/src/auth/AuthMessages.h
+++ b/src/auth/AuthMessages.h
@@ -97,6 +97,7 @@ namespace SDDM {
         REQUEST,
         AUTHENTICATED,
         SESSION_STATUS,
+        DISPLAY_SERVER_STARTED,
         MSG_LAST,
     };
 
diff --git a/src/auth/AuthPrompt.h b/src/auth/AuthPrompt.h
index 8ed394d..dcaa539 100644
--- a/src/auth/AuthPrompt.h
+++ b/src/auth/AuthPrompt.h
@@ -40,7 +40,6 @@ namespace SDDM {
     */
     class AuthPrompt : public QObject {
         Q_OBJECT
-        Q_ENUMS(Type)
         Q_PROPERTY(Type type READ type CONSTANT)
         Q_PROPERTY(QString message READ message CONSTANT)
         Q_PROPERTY(bool hidden READ hidden CONSTANT)
@@ -59,6 +58,7 @@ namespace SDDM {
             LOGIN_USER = 0x0080,      ///< On logging in: The username
             LOGIN_PASSWORD            ///< On logging in: The password
         };
+        Q_ENUM(Type)
         /**
         * @return the type of the prompt
         */
@@ -99,4 +99,4 @@ namespace SDDM {
     };
 }
 
-#endif //PROMPT_H
\ No newline at end of file
+#endif //PROMPT_H
diff --git a/src/auth/AuthRequest.cpp b/src/auth/AuthRequest.cpp
index 9583b0a..9ccc2d2 100644
--- a/src/auth/AuthRequest.cpp
+++ b/src/auth/AuthRequest.cpp
@@ -73,7 +73,7 @@ namespace SDDM {
     }
 
     QQmlListProperty<AuthPrompt> AuthRequest::promptsDecl() {
-        return QQmlListProperty<AuthPrompt>(this, d->prompts);
+        return QQmlListProperty<AuthPrompt>(this, &d->prompts);
     }
 
     void AuthRequest::done() {
diff --git a/src/common/ConfigReader.cpp b/src/common/ConfigReader.cpp
index 041e5ed..503b55e 100644
--- a/src/common/ConfigReader.cpp
+++ b/src/common/ConfigReader.cpp
@@ -265,7 +265,7 @@ namespace SDDM {
         QByteArray junk;
         // stores the junk to the temporary storage
         auto collectJunk = [&junk](const QString &data) {
-            junk.append(data);
+            junk.append(data.toUtf8());
         };
 
         // a short function to assign the current junk and current line to the right section, eventually create a new one
@@ -275,7 +275,7 @@ namespace SDDM {
                 sectionData[currentSection] = QByteArray();
             }
             sectionData[currentSection].append(junk);
-            sectionData[currentSection].append(data);
+            sectionData[currentSection].append(data.toUtf8());
             junk.clear();
         };
 
diff --git a/src/common/Configuration.h b/src/common/Configuration.h
index cf44a62..cdffde3 100644
--- a/src/common/Configuration.h
+++ b/src/common/Configuration.h
@@ -37,6 +37,9 @@ namespace SDDM {
         enum NumState { NUM_NONE, NUM_SET_ON, NUM_SET_OFF };
 
         //  Name                   Type         Default value                                   Description
+        // TODO: Change default to x11-user in a future release
+        Entry(DisplayServer,       QString,     _S("x11"),                                      _S("Which display server should be used.\n"
+                                                                                                   "Valid values are: x11, x11-user, wayland."));
         Entry(HaltCommand,         QString,     _S(HALT_COMMAND),                               _S("Halt command"));
         Entry(RebootCommand,       QString,     _S(REBOOT_COMMAND),                             _S("Reboot command"));
         Entry(Numlock,             NumState,    NUM_NONE,                                       _S("Initial NumLock state. Can be on, off or none.\n"
@@ -44,6 +47,7 @@ namespace SDDM {
                                                                                                    "NOTE: Currently ignored if autologin is enabled."));
         Entry(InputMethod,         QString,     QStringLiteral("qtvirtualkeyboard"),                   _S("Input method module"));
         Entry(Namespaces,          QStringList, QStringList(),                                  _S("Comma-separated list of Linux namespaces for user session to enter"));
+        Entry(GreeterEnvironment,  QStringList, QStringList(),                                  _S("Comma-separated list of environment variables to be set"));
         //  Name   Entries (but it's a regular class again)
         Section(Theme,
             Entry(ThemeDir,            QString,     _S(DATA_INSTALL_DIR "/themes"),             _S("Theme directory path"));
@@ -51,6 +55,7 @@ namespace SDDM {
             Entry(FacesDir,            QString,     _S(DATA_INSTALL_DIR "/faces"),              _S("Global directory for user avatars\n"
                                                                                                    "The files should be named <username>.face.icon"));
             Entry(CursorTheme,         QString,     QString(),                                  _S("Cursor theme used in the greeter"));
+            Entry(CursorSize,          QString,     QString(),                                  _S("Cursor size used in the greeter"));
             Entry(Font,                QString,     QString(),                                  _S("Font used in the greeter"));
             Entry(EnableAvatars,       bool,        true,                                       _S("Enable display of custom user avatars"));
             Entry(DisableAvatarsThreshold,int,      7,                                          _S("Number of users to use as threshold\n"
@@ -70,11 +75,11 @@ namespace SDDM {
 	    Entry(UserAuthFile,        QString,     _S(".Xauthority"),                          _S("Path to the Xauthority file"));
             Entry(DisplayCommand,      QString,     _S(DATA_INSTALL_DIR "/scripts/Xsetup"),     _S("Path to a script to execute when starting the display server"));
             Entry(DisplayStopCommand,  QString,     _S(DATA_INSTALL_DIR "/scripts/Xstop"),      _S("Path to a script to execute when stopping the display server"));
-            Entry(MinimumVT,           int,         MINIMUM_VT,                                 _S("The lowest virtual terminal number that will be used."));
             Entry(EnableHiDPI,         bool,        false,                                      _S("Enable Qt's automatic high-DPI scaling"));
         );
 
         Section(Wayland,
+            Entry(CompositorCommand,   QString,     _S("weston --shell=fullscreen-shell.so"),   _S("Path of the Wayland compositor to execute when starting the greeter"));
             Entry(SessionDir,          QString,     _S("/usr/share/wayland-sessions"),          _S("Directory containing available Wayland sessions"));
             Entry(SessionCommand,      QString,     _S(WAYLAND_SESSION_COMMAND),                _S("Path to a script to execute when starting the desktop session"));
 	    Entry(SessionLogFile,      QString,     _S(".local/share/sddm/wayland-session.log"),_S("Path to the user session log file"));
diff --git a/src/common/Constants.h.in b/src/common/Constants.h.in
index e174b5b..4805128 100644
--- a/src/common/Constants.h.in
+++ b/src/common/Constants.h.in
@@ -37,7 +37,6 @@
 #define SYSTEM_CONFIG_DIR           "@SYSTEM_CONFIG_DIR@"
 
 #define LOG_FILE                    "@LOG_FILE@"
-#define MINIMUM_VT                  @MINIMUM_VT@
 
 #define UID_MIN                     @UID_MIN@
 #define UID_MAX                     @UID_MAX@
diff --git a/src/common/MessageHandler.h b/src/common/MessageHandler.h
index ba45d82..ef5e8df 100644
--- a/src/common/MessageHandler.h
+++ b/src/common/MessageHandler.h
@@ -24,7 +24,9 @@
 #include "Constants.h"
 
 #include <QDateTime>
+#include <QStandardPaths>
 #include <QFile>
+#include <QDir>
 
 #include <stdio.h>
 
@@ -75,6 +77,16 @@ namespace SDDM {
                 file.open(QFile::Truncate | QFile::WriteOnly);
         }
 
+        // If we can't open the file, create it in a writable location
+        // It will look spmething like ~/.local/share/$appname/sddm.log
+        // or for the sddm user /var/lib/sddm/.local/share/$appname/sddm.log
+        if (!file.isOpen()) {
+            QDir().mkpath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation));
+            file.setFileName(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + QLatin1String("/sddm.log"));
+            if (!file.open(QFile::Append | QFile::WriteOnly))
+                file.open(QFile::Truncate | QFile::WriteOnly);
+        }
+
         // create timestamp
         QString timestamp = QDateTime::currentDateTime().toString(QStringLiteral("hh:mm:ss.zzz"));
 
diff --git a/src/common/Session.cpp b/src/common/Session.cpp
index 2d7b04f..1b932c5 100644
--- a/src/common/Session.cpp
+++ b/src/common/Session.cpp
@@ -52,6 +52,16 @@ namespace SDDM {
         return m_type;
     }
 
+    int Session::vt() const
+    {
+        return m_vt;
+    }
+
+    void Session::setVt(int vt)
+    {
+        m_vt = vt;
+    }
+
     QString Session::xdgSessionType() const
     {
         return m_xdgSessionType;
@@ -89,7 +99,7 @@ namespace SDDM {
 
     QString Session::desktopSession() const
     {
-        return fileName().replace(s_entryExtention, QString());
+        return QFileInfo(m_fileName).completeBaseName();
     }
 
     QString Session::desktopNames() const
@@ -107,6 +117,10 @@ namespace SDDM {
         return m_isNoDisplay;
     }
 
+    QProcessEnvironment Session::additionalEnv() const {
+        return m_additionalEnv;
+    }
+
     void Session::setTo(Type type, const QString &_fileName)
     {
         QString fileName(_fileName);
@@ -157,15 +171,8 @@ namespace SDDM {
             if (current_section != QLatin1String("Desktop Entry"))
                 continue; // We are only interested in the "Desktop Entry" section
 
-            if (line.startsWith(QLatin1String("Name="))) {
-                if (type == WaylandSession)
-                    if (line.mid(5).endsWith(QLatin1String(" (Wayland)")))
-                        m_displayName = QObject::tr("%1").arg(line.mid(5));
-                    else
-                        m_displayName = QObject::tr("%1 (Wayland)").arg(line.mid(5));
-                else
-                    m_displayName = line.mid(5);
-            }
+            if (line.startsWith(QLatin1String("Name=")))
+                m_displayName = line.mid(5);
             if (line.startsWith(QLatin1String("Comment=")))
                 m_comment = line.mid(8);
             if (line.startsWith(QLatin1String("Exec=")))
@@ -178,6 +185,8 @@ namespace SDDM {
                 m_isHidden = line.mid(7).toLower() == QLatin1String("true");
             if (line.startsWith(QLatin1String("NoDisplay=")))
                 m_isNoDisplay = line.mid(10).toLower() == QLatin1String("true");
+            if (line.startsWith(QLatin1String("X-SDDM-Env=")))
+                m_additionalEnv = parseEnv(line.mid(strlen("X-SDDM-Env=")));
         }
 
         file.close();
@@ -191,4 +200,22 @@ namespace SDDM {
         setTo(other.type(), other.fileName());
         return *this;
     }
+
+    QProcessEnvironment SDDM::Session::parseEnv(const QString &list)
+    {
+        QProcessEnvironment env;
+
+        const QVector<QStringRef> entryList = list.splitRef(QLatin1Char(','));
+        for (const auto &entry: entryList) {
+            int midPoint = entry.indexOf(QLatin1Char('='));
+            if (midPoint < 0) {
+                qWarning() << "Malformed entry in" << fileName() << ":" << entry;
+                continue;
+            }
+            env.insert(entry.left(midPoint).toString(), entry.mid(midPoint+1).toString());
+        }
+        return env;
+    }
+
+
 }
diff --git a/src/common/Session.h b/src/common/Session.h
index 9fd86cd..3abc993 100644
--- a/src/common/Session.h
+++ b/src/common/Session.h
@@ -23,6 +23,7 @@
 #include <QDataStream>
 #include <QDir>
 #include <QSharedPointer>
+#include <QProcessEnvironment>
 
 namespace SDDM {
     class SessionModel;
@@ -42,6 +43,9 @@ namespace SDDM {
 
         Type type() const;
 
+        int vt() const;
+        void setVt(int vt);
+
         QString xdgSessionType() const;
 
         QDir directory() const;
@@ -59,13 +63,17 @@ namespace SDDM {
         bool isHidden() const;
         bool isNoDisplay() const;
 
+        QProcessEnvironment additionalEnv() const;
+
         void setTo(Type type, const QString &name);
 
         Session &operator=(const Session &other);
 
     private:
+        QProcessEnvironment parseEnv(const QString &list);
         bool m_valid;
         Type m_type;
+        int m_vt = 0;
         QDir m_dir;
         QString m_name;
         QString m_fileName;
@@ -75,6 +83,7 @@ namespace SDDM {
         QString m_tryExec;
         QString m_xdgSessionType;
         QString m_desktopNames;
+        QProcessEnvironment m_additionalEnv;
         bool m_isHidden;
         bool m_isNoDisplay;
 
diff --git a/src/daemon/SignalHandler.cpp b/src/common/SignalHandler.cpp
similarity index 81%
rename from src/daemon/SignalHandler.cpp
rename to src/common/SignalHandler.cpp
index 810105e..c659746 100644
--- a/src/daemon/SignalHandler.cpp
+++ b/src/common/SignalHandler.cpp
@@ -32,6 +32,7 @@ namespace SDDM {
     int sigintFd[2];
     int sigtermFd[2];
     int sigusr1Fd[2];
+    int sigcustomFd[2];
 
     SignalHandler::SignalHandler(QObject *parent) : QObject(parent) {
         if (::socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, sighupFd))
@@ -57,6 +58,12 @@ namespace SDDM {
 
         snusr1 = new QSocketNotifier(sigusr1Fd[1], QSocketNotifier::Read, this);
         connect(snusr1, &QSocketNotifier::activated, this, &SignalHandler::handleSigusr1);
+
+        if (::socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, sigcustomFd))
+            qCritical() << "Failed to create socket pair for custom signals handling.";
+
+        sncustom = new QSocketNotifier(sigcustomFd[1], QSocketNotifier::Read, this);
+        connect(sncustom, &QSocketNotifier::activated, this, &SignalHandler::handleSigCustom);
     }
 
     void SignalHandler::initialize() {
@@ -103,6 +110,20 @@ namespace SDDM {
         }
     }
 
+    void SignalHandler::addCustomSignal(int signal)
+    {
+        struct sigaction sigcustom = { };
+        sigcustom.sa_handler = SignalHandler::customSignalHandler;
+        sigemptyset(&sigcustom.sa_mask);
+        sigcustom.sa_flags = SA_RESTART;
+
+        if (sigaction(signal, &sigcustom, 0) > 0) {
+            qCritical() << "Failed to set up " << strsignal(signal) << " handler.";
+            return;
+        }
+    }
+
+
     void SignalHandler::ignoreSigusr1() {
         struct sigaction sigusr1 = { };
         sigusr1.sa_handler = SIG_IGN;
@@ -146,6 +167,12 @@ namespace SDDM {
             return;
         }
     }
+    void SignalHandler::customSignalHandler(int signal) {
+        if (::write(sigcustomFd[0], &signal, sizeof(signal)) == -1) {
+            qCritical() << "Error writing to the " << strsignal(signal) << " handler";
+            return;
+        }
+    }
 
     void SignalHandler::handleSighup() {
         // disable notifier
@@ -234,4 +261,28 @@ namespace SDDM {
         // enable notifier
         snusr1->setEnabled(true);
     }
+
+    void SignalHandler::handleSigCustom() {
+        // disable notifier
+        sncustom->setEnabled(false);
+
+        // read from socket
+        int signal;
+        if (::read(sigcustomFd[1], &signal, sizeof(signal)) == -1) {
+            // something went wrong!
+            qCritical() << "Error reading from the socket";
+            return;
+        }
+
+        // log event
+        qWarning() << "Signal received: " << strsignal(signal);
+
+        // emit signal
+        emit customSignalReceived(signal);
+
+        // enable notifier
+        sncustom->setEnabled(true);
+    }
+
+
 }
diff --git a/src/daemon/SignalHandler.h b/src/common/SignalHandler.h
similarity index 90%
rename from src/daemon/SignalHandler.h
rename to src/common/SignalHandler.h
index 567ce07..bacf797 100644
--- a/src/daemon/SignalHandler.h
+++ b/src/common/SignalHandler.h
@@ -38,24 +38,30 @@ namespace SDDM {
         static void intSignalHandler(int unused);
         static void termSignalHandler(int unused);
         static void usr1SignalHandler(int unused);
+        static void customSignalHandler(int unused);
+
+        void addCustomSignal(int signal);
 
     signals:
         void sighupReceived();
         void sigintReceived();
         void sigtermReceived();
         void sigusr1Received();
+        void customSignalReceived(int signal);
 
     private slots:
         void handleSighup();
         void handleSigint();
         void handleSigterm();
         void handleSigusr1();
+        void handleSigCustom();
 
     private:
         QSocketNotifier *snhup { nullptr };
         QSocketNotifier *snint { nullptr };
         QSocketNotifier *snterm { nullptr };
         QSocketNotifier *snusr1 { nullptr };
+        QSocketNotifier *sncustom { nullptr };
     };
 }
 #endif // SDDM_SIGNALHANDLER_H
diff --git a/src/common/VirtualTerminal.cpp b/src/common/VirtualTerminal.cpp
index 3ce6aff..e1330af 100644
--- a/src/common/VirtualTerminal.cpp
+++ b/src/common/VirtualTerminal.cpp
@@ -30,6 +30,7 @@
 #include <linux/vt.h>
 #include <linux/kd.h>
 #include <sys/ioctl.h>
+#include <qscopeguard.h>
 
 #define RELEASE_DISPLAY_SIGNAL (SIGRTMAX)
 #define ACQUIRE_DISPLAY_SIGNAL (SIGRTMAX - 1)
@@ -115,32 +116,57 @@ out:
                 qDebug() << "VT mode didn't need to be fixed";
         }
 
-        int setUpNewVt() {
+        int fetchAvailableVt() {
             // open VT master
             int fd = open("/dev/tty0", O_RDWR | O_NOCTTY);
             if (fd < 0) {
                 qCritical() << "Failed to open VT master:" << strerror(errno);
                 return -1;
             }
+            auto closeFd = qScopeGuard([fd] {
+                close(fd);
+            });
 
             vt_stat vtState = { 0 };
             if (ioctl(fd, VT_GETSTATE, &vtState) < 0) {
                 qCritical() << "Failed to get current VT:" << strerror(errno);
-                close(fd);
+
+                int vt = 0;
+                // If there's no current tty, request the next to open
+                if (ioctl(fd, VT_OPENQRY, &vt) < 0) {
+                    qCritical() << "Failed to open new VT:" << strerror(errno);
+                    return -1;
+                }
+                return vt;
+            }
+            return vtState.v_active;
+        }
+
+        int setUpNewVt() {
+            // open VT master
+            int fd = open("/dev/tty0", O_RDWR | O_NOCTTY);
+            if (fd < 0) {
+                qCritical() << "Failed to open VT master:" << strerror(errno);
                 return -1;
             }
+            auto closeFd = qScopeGuard([fd] {
+                close(fd);
+            });
 
             int vt = 0;
             if (ioctl(fd, VT_OPENQRY, &vt) < 0) {
                 qCritical() << "Failed to open new VT:" << strerror(errno);
-                close(fd);
                 return -1;
             }
 
-            close(fd);
-
             // fallback to active VT
             if (vt <= 0) {
+                vt_stat vtState = { 0 };
+                if (ioctl(fd, VT_GETSTATE, &vtState) < 0) {
+                    qCritical() << "Failed to get current VT:" << strerror(errno);
+                    return -1;
+                }
+
                 qWarning() << "New VT" << vt << "is not valid, fall back to" << vtState.v_active;
                 return vtState.v_active;
             }
@@ -160,6 +186,10 @@ out:
             if (vtFd != -1) {
                 fd = vtFd;
 
+                // Clear VT
+                static const char *clearEscapeSequence = "\33[H\33[2J";
+                write(vtFd, clearEscapeSequence, sizeof(clearEscapeSequence));
+
                 // set graphics mode to prevent flickering
                 if (ioctl(fd, KDSETMODE, KD_GRAPHICS) < 0)
                     qWarning("Failed to set graphics mode for VT %d: %s", vt, strerror(errno));
diff --git a/src/common/VirtualTerminal.h b/src/common/VirtualTerminal.h
index 1b17086..2230049 100644
--- a/src/common/VirtualTerminal.h
+++ b/src/common/VirtualTerminal.h
@@ -22,6 +22,7 @@
 
 namespace SDDM {
     namespace VirtualTerminal {
+        int fetchAvailableVt();
         int setUpNewVt();
         void jumpToVt(int vt, bool vt_auto);
     }
diff --git a/src/common/VirtualTerminal_FreeBSD.cpp b/src/common/VirtualTerminal_FreeBSD.cpp
index aaf1b61..55de967 100644
--- a/src/common/VirtualTerminal_FreeBSD.cpp
+++ b/src/common/VirtualTerminal_FreeBSD.cpp
@@ -1,5 +1,6 @@
 /***************************************************************************
 * Copyright (c) 2015 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+* Copyright (c) 2021 Gleb Popov <arrowd@freebsd.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
@@ -22,16 +23,62 @@
 
 #include "VirtualTerminal.h"
 
+#include <fcntl.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <sys/consio.h>
+
 
 namespace SDDM {
     namespace VirtualTerminal {
+        static char ttyvX[] = "/dev/ttyvX";
+        static const char ttyvs[] = "0123456789ab";
+
         int setUpNewVt() {
-            qDebug() << "New VT is unsupported on FreeBSD";
-            return -1;
+            // there is no way to create VTs on FreeBSD, so
+            // just try to fetch any available
+            return fetchAvailableVt();
         }
 
         void jumpToVt(int vt, bool vt_auto) {
-            qDebug() << "Jumping to VT" << vt << "is unsupported on FreeBSD";
+            int fd = -1;
+
+            for (int i = 0; i < sizeof(ttyvs) / sizeof(char); i++) {
+                ttyvX[9] = ttyvs[i];
+                fd = ::open(ttyvX, O_RDONLY);
+                if (fd != -1)
+                    break;
+                if (fd == -1 && errno == EACCES)
+                    continue;
+                qWarning() << "open(" << ttyvX << ") failed: " << strerror(errno);
+            }
+
+            if (fd == -1) {
+                qWarning() << "Jumping to VT" << vt << " failed: can't open any /dev/ttyvX";
+                return;
+            }
+
+            if (::ioctl(fd, VT_ACTIVATE, vt) == -1) {
+                qWarning() << "ioctl(VT_ACTIVATE) failed: " << strerror(errno);
+            }
+        }
+
+        int fetchAvailableVt() {
+            int fd = ::open("/dev/console", O_RDONLY);
+            if(fd == -1) {
+                qWarning() << "Failed to open /dev/console: " << strerror(errno);
+                return -1;
+            }
+
+            int vt;
+            int err = ::ioctl(fd, VT_OPENQRY, &vt);
+            if(err == -1) {
+                qWarning() << "ioctl(VT_OPENQRY) failed: " << strerror(errno);
+                return -1;
+            }
+
+            return vt;
         }
     }
 }
diff --git a/src/common/XAuth.cpp b/src/common/XAuth.cpp
new file mode 100644
index 0000000..bc7b10c
--- /dev/null
+++ b/src/common/XAuth.cpp
@@ -0,0 +1,127 @@
+/***************************************************************************
+* Copyright (c) 2021 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+* Copyright (c) 2013 Abdurrahman AVCI <abdurrahmanavci@gmail.com>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#include <QDebug>
+#include <QDir>
+#include <QUuid>
+
+#include "Configuration.h"
+#include "Constants.h"
+#include "XAuth.h"
+
+#include <random>
+
+namespace SDDM {
+
+XAuth::XAuth()
+{
+    m_authDir = QStringLiteral(RUNTIME_DIR);
+}
+
+QString XAuth::authDirectory() const
+{
+    return m_authDir;
+}
+
+void XAuth::setAuthDirectory(const QString &path)
+{
+    if (m_setup) {
+        qWarning("Unable to set xauth directory after setup");
+        return;
+    }
+
+    m_authDir = path;
+}
+
+QString XAuth::authPath() const
+{
+    return m_authPath;
+}
+
+QString XAuth::cookie() const
+{
+    return m_cookie;
+}
+
+void XAuth::setup()
+{
+    if (m_setup)
+        return;
+
+    m_setup = true;
+
+    // Create directory if not existing
+    QDir().mkpath(m_authDir);
+
+    // Set path
+    m_authPath = QStringLiteral("%1/%2").arg(m_authDir).arg(QUuid::createUuid().toString(QUuid::WithoutBraces));
+    qDebug() << "Xauthority path:" << m_authPath;
+
+    // Generate cookie
+    std::random_device rd;
+    std::mt19937 gen(rd());
+    std::uniform_int_distribution<> dis(0, 15);
+
+    // Reseve 32 bytes
+    m_cookie.reserve(32);
+
+    // Create a random hexadecimal number
+    const char *digits = "0123456789abcdef";
+    for (int i = 0; i < 32; ++i)
+        m_cookie[i] = QLatin1Char(digits[dis(gen)]);
+}
+
+bool XAuth::addCookie(const QString &display)
+{
+    if (!m_setup) {
+        qWarning("Please setup xauth before adding a cookie");
+        return false;
+    }
+
+    return XAuth::addCookieToFile(display, m_authPath, m_cookie);
+}
+
+bool XAuth::addCookieToFile(const QString &display, const QString &fileName,
+                            const QString &cookie)
+{
+    qDebug() << "Adding cookie to" << fileName;
+
+    // Touch file
+    QFile file_handler(fileName);
+    file_handler.open(QIODevice::Append);
+    file_handler.close();
+
+    QString cmd = QStringLiteral("%1 -f %2 -q").arg(mainConfig.X11.XauthPath.get()).arg(fileName);
+
+    // Execute xauth
+    FILE *fp = ::popen(qPrintable(cmd), "w");
+
+    // Check file
+    if (!fp)
+        return false;
+    fprintf(fp, "remove %s\n", qPrintable(display));
+    fprintf(fp, "add %s . %s\n", qPrintable(display), qPrintable(cookie));
+    fprintf(fp, "exit\n");
+
+    // Close pipe
+    return pclose(fp) == 0;
+}
+
+} // namespace SDDM
diff --git a/src/common/XAuth.h b/src/common/XAuth.h
new file mode 100644
index 0000000..3e80f4e
--- /dev/null
+++ b/src/common/XAuth.h
@@ -0,0 +1,55 @@
+/***************************************************************************
+* Copyright (c) 2021 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+* Copyright (c) 2013 Abdurrahman AVCI <abdurrahmanavci@gmail.com>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#ifndef SDDM_XAUTH_H
+#define SDDM_XAUTH_H
+
+#include <QString>
+
+namespace SDDM {
+
+class XAuth
+{
+public:
+    XAuth();
+
+    QString authDirectory() const;
+    void setAuthDirectory(const QString &path);
+
+    QString authPath() const;
+    QString cookie() const;
+
+    void setup();
+    bool addCookie(const QString &display);
+
+    static bool addCookieToFile(const QString &display,
+                                const QString &fileName,
+                                const QString &cookie);
+
+private:
+    bool m_setup = false;
+    QString m_authDir;
+    QString m_authPath;
+    QString m_cookie;
+};
+
+} // namespace SDDM
+
+#endif // SDDM_XAUTH_H
diff --git a/src/daemon/CMakeLists.txt b/src/daemon/CMakeLists.txt
index 86d014b..678a92a 100644
--- a/src/daemon/CMakeLists.txt
+++ b/src/daemon/CMakeLists.txt
@@ -13,6 +13,8 @@ set(DAEMON_SOURCES
     ${CMAKE_SOURCE_DIR}/src/common/ThemeMetadata.cpp
     ${CMAKE_SOURCE_DIR}/src/common/Session.cpp
     ${CMAKE_SOURCE_DIR}/src/common/SocketWriter.cpp
+    ${CMAKE_SOURCE_DIR}/src/common/XAuth.cpp
+    ${CMAKE_SOURCE_DIR}/src/common/SignalHandler.cpp
     ${CMAKE_SOURCE_DIR}/src/auth/Auth.cpp
     ${CMAKE_SOURCE_DIR}/src/auth/AuthPrompt.cpp
     ${CMAKE_SOURCE_DIR}/src/auth/AuthRequest.cpp
@@ -22,13 +24,16 @@ set(DAEMON_SOURCES
     DisplayManager.cpp
     DisplayServer.cpp
     LogindDBusTypes.cpp
-    XorgDisplayServer.cpp
     Greeter.cpp
     PowerManager.cpp
     Seat.cpp
     SeatManager.cpp
-    SignalHandler.cpp
     SocketServer.cpp
+    XorgDisplayServer.cpp
+    XorgUserDisplayServer.cpp
+    XorgUserDisplayServer.h
+    WaylandDisplayServer.cpp
+    WaylandDisplayServer.h
 )
 
 # Different implementations of the VT switching code
diff --git a/src/daemon/DaemonApp.cpp b/src/daemon/DaemonApp.cpp
index 2b9b9f6..9e4df65 100644
--- a/src/daemon/DaemonApp.cpp
+++ b/src/daemon/DaemonApp.cpp
@@ -28,6 +28,7 @@
 
 #include "MessageHandler.h"
 
+#include <QDBusConnectionInterface>
 #include <QDebug>
 #include <QHostInfo>
 #include <QTimer>
@@ -49,6 +50,21 @@ namespace SDDM {
         // set testing parameter
         m_testing = (arguments().indexOf(QStringLiteral("--test-mode")) != -1);
 
+        bool consoleKitServiceActivatable = false;
+        QDBusReply<QStringList> activatableNamesReply = QDBusConnection::systemBus().interface()->activatableServiceNames();
+        if (activatableNamesReply.isValid()) {
+            consoleKitServiceActivatable = activatableNamesReply.value().contains(QStringLiteral("org.freedesktop.ConsoleKit"));
+        }
+
+        // If ConsoleKit isn't started by the OS init system (FreeBSD, for instance),
+        // we start it ourselves during the sddm startup
+        if (consoleKitServiceActivatable) {
+            QDBusReply<bool> registeredReply = QDBusConnection::systemBus().interface()->isServiceRegistered(QStringLiteral("org.freedesktop.ConsoleKit"));
+            if (registeredReply.isValid() && registeredReply.value() == false) {
+                QDBusConnection::systemBus().interface()->startService(QStringLiteral("org.freedesktop.ConsoleKit"));
+            }
+        }
+
         // create display manager
         m_displayManager = new DisplayManager(this);
 
diff --git a/src/daemon/Display.cpp b/src/daemon/Display.cpp
index b95f6e5..0983308 100644
--- a/src/daemon/Display.cpp
+++ b/src/daemon/Display.cpp
@@ -25,11 +25,11 @@
 #include "DaemonApp.h"
 #include "DisplayManager.h"
 #include "XorgDisplayServer.h"
+#include "XorgUserDisplayServer.h"
 #include "Seat.h"
 #include "SocketServer.h"
 #include "Greeter.h"
 #include "Utils.h"
-#include "SignalHandler.h"
 
 #include <QDebug>
 #include <QFile>
@@ -38,6 +38,7 @@
 
 #include <pwd.h>
 #include <unistd.h>
+#include <sys/time.h>
 
 #include <QDBusConnection>
 #include <QDBusMessage>
@@ -45,17 +46,52 @@
 
 #include "Login1Manager.h"
 #include "Login1Session.h"
+#include "VirtualTerminal.h"
+#include "WaylandDisplayServer.h"
 
 
 namespace SDDM {
-    Display::Display(const int terminalId, Seat *parent) : QObject(parent),
-        m_terminalId(terminalId),
+    Display::Display(Seat *parent) : QObject(parent),
         m_auth(new Auth(this)),
-        m_displayServer(new XorgDisplayServer(this)),
         m_seat(parent),
         m_socketServer(new SocketServer(this)),
         m_greeter(new Greeter(this)) {
 
+
+        // Save display server type
+        const QString &displayServerType = mainConfig.DisplayServer.get().toLower();
+        if (displayServerType == QStringLiteral("x11-user")) {
+            m_displayServerType = X11UserDisplayServerType;
+            m_terminalId = VirtualTerminal::fetchAvailableVt();
+        } else if (displayServerType == QStringLiteral("wayland")) {
+            m_displayServerType = WaylandDisplayServerType;
+            m_terminalId = VirtualTerminal::fetchAvailableVt();
+        } else {
+            if (displayServerType != QLatin1String("x11")) {
+                qWarning("\"%s\" is an invalid value for General.DisplayServer: fall back to \"x11\"",
+                     qPrintable(displayServerType));
+            }
+            m_terminalId = VirtualTerminal::setUpNewVt();
+            m_displayServerType = X11DisplayServerType;
+        }
+
+        // Create display server
+        switch (m_displayServerType) {
+        case X11DisplayServerType:
+            m_displayServer = new XorgDisplayServer(this);
+            break;
+        case X11UserDisplayServerType:
+            m_displayServer = new XorgUserDisplayServer(this);
+            m_greeter->setDisplayServerCommand(XorgUserDisplayServer::command(this));
+            break;
+        case WaylandDisplayServerType:
+            m_displayServer = new WaylandDisplayServer(this);
+            m_greeter->setDisplayServerCommand(mainConfig.Wayland.CompositorCommand.get());
+            break;
+        }
+
+        qDebug("Using VT %d", m_terminalId);
+
         // respond to authentication requests
         m_auth->setVerbose(true);
         connect(m_auth, &Auth::requestChanged, this, &Display::slotRequestChanged);
@@ -73,16 +109,28 @@ namespace SDDM {
         connect(m_socketServer, &SocketServer::login, this, &Display::login);
 
         // connect login result signals
-        connect(this, SIGNAL(loginFailed(QLocalSocket*)), m_socketServer, SLOT(loginFailed(QLocalSocket*)));
-        connect(this, SIGNAL(loginSucceeded(QLocalSocket*)), m_socketServer, SLOT(loginSucceeded(QLocalSocket*)));
+        connect(this, &Display::loginFailed, m_socketServer, &SocketServer::loginFailed);
+        connect(this, &Display::loginSucceeded, m_socketServer, &SocketServer::loginSucceeded);
+
+        connect(m_greeter, &Greeter::failed,
+                QCoreApplication::instance(), [] {
+                    QCoreApplication::instance()->exit(23);
+                });
     }
 
     Display::~Display() {
+        disconnect(m_auth, &Auth::finished, this, &Display::slotHelperFinished);
         stop();
     }
 
-    QString Display::displayId() const {
-        return m_displayServer->display();
+    Display::DisplayServerType Display::displayServerType() const
+    {
+        return m_displayServerType;
+    }
+
+    DisplayServer *Display::displayServer() const
+    {
+        return m_displayServer;
     }
 
     const int Display::terminalId() const {
@@ -154,6 +202,8 @@ namespace SDDM {
             bool success = attemptAutologin();
             if (success) {
                 return;
+            } else {
+                qWarning() << "Autologin failed!";
             }
         }
 
@@ -172,8 +222,8 @@ namespace SDDM {
         }
 
         // set greeter params
-        m_greeter->setDisplay(this);
-        m_greeter->setAuthPath(qobject_cast<XorgDisplayServer *>(m_displayServer)->authPath());
+        if (qobject_cast<XorgDisplayServer *>(m_displayServer))
+            m_greeter->setAuthPath(qobject_cast<XorgDisplayServer *>(m_displayServer)->authPath());
         m_greeter->setSocket(m_socketServer->socketAddress());
         m_greeter->setTheme(findGreeterTheme());
 
@@ -195,6 +245,8 @@ namespace SDDM {
         // stop the greeter
         m_greeter->stop();
 
+        m_auth->stop();
+
         // stop socket server
         m_socketServer->stop();
 
@@ -245,6 +297,11 @@ namespace SDDM {
     }
 
     bool Display::findSessionEntry(const QDir &dir, const QString &name) const {
+        // Given an absolute path: Check that it matches dir
+        const QFileInfo fileInfo(name);
+        if (fileInfo.isAbsolute() && fileInfo.absolutePath() != dir.absolutePath())
+            return false;
+
         QString fileName = name;
 
         // append extension
@@ -297,41 +354,49 @@ namespace SDDM {
             }
         }
 
-        // cache last session
-        m_lastSession = session;
-
         // save session desktop file name, we'll use it to set the
         // last session later, in slotAuthenticationFinished()
         m_sessionName = session.fileName();
 
+        int terminalNewSession = m_terminalId;
+        if ((session.type() == Session::WaylandSession && m_displayServerType == X11DisplayServerType) || m_greeter->isRunning()) {
+            // Create a new VT when we need to have another compositor running
+            terminalNewSession = VirtualTerminal::setUpNewVt();
+        }
+
         // some information
-        qDebug() << "Session" << m_sessionName << "selected, command:" << session.exec();
+        qDebug() << "Session" << m_sessionName << "selected, command:" << session.exec() << "for VT" << terminalNewSession;
 
         QProcessEnvironment env;
-
-        if (seat()->name() == QLatin1String("seat0")) {
-            // Use the greeter VT, for wayland sessions the helper overwrites this
-            env.insert(QStringLiteral("XDG_VTNR"), QString::number(terminalId()));
-        }
+        env.insert(session.additionalEnv());
 
         env.insert(QStringLiteral("PATH"), mainConfig.Users.DefaultPath.get());
-        if (session.xdgSessionType() == QLatin1String("x11"))
-            env.insert(QStringLiteral("DISPLAY"), name());
         env.insert(QStringLiteral("XDG_SEAT_PATH"), daemonApp->displayManager()->seatPath(seat()->name()));
         env.insert(QStringLiteral("XDG_SESSION_PATH"), daemonApp->displayManager()->sessionPath(QStringLiteral("Session%1").arg(daemonApp->newSessionId())));
         env.insert(QStringLiteral("DESKTOP_SESSION"), session.desktopSession());
-        env.insert(QStringLiteral("XDG_CURRENT_DESKTOP"), session.desktopNames());
+        if (!session.desktopNames().isEmpty())
+            env.insert(QStringLiteral("XDG_CURRENT_DESKTOP"), session.desktopNames());
         env.insert(QStringLiteral("XDG_SESSION_CLASS"), QStringLiteral("user"));
         env.insert(QStringLiteral("XDG_SESSION_TYPE"), session.xdgSessionType());
         env.insert(QStringLiteral("XDG_SEAT"), seat()->name());
+        env.insert(QStringLiteral("XDG_VTNR"), QString::number(terminalNewSession));
+#ifdef HAVE_SYSTEMD
         env.insert(QStringLiteral("XDG_SESSION_DESKTOP"), session.desktopNames());
+#endif
 
-        m_auth->insertEnvironment(env);
-
+        if (session.xdgSessionType() == QLatin1String("x11")) {
+          if (m_displayServerType == X11DisplayServerType)
+            env.insert(QStringLiteral("DISPLAY"), name());
+          else
+            m_auth->setDisplayServerCommand(XorgUserDisplayServer::command(this));
+        } else {
+            m_auth->setDisplayServerCommand(QStringLiteral());
+	}
         m_auth->setUser(user);
         if (m_reuseSessionId.isNull()) {
             m_auth->setSession(session.exec());
         }
+        m_auth->insertEnvironment(env);
         m_auth->start();
     }
 
@@ -344,7 +409,8 @@ namespace SDDM {
                 manager.UnlockSession(m_reuseSessionId);
                 manager.ActivateSession(m_reuseSessionId);
             } else {
-                m_auth->setCookie(qobject_cast<XorgDisplayServer *>(m_displayServer)->cookie());
+                if (qobject_cast<XorgDisplayServer *>(m_displayServer))
+                    m_auth->setCookie(qobject_cast<XorgDisplayServer *>(m_displayServer)->cookie());
             }
 
             // save last user and last session
diff --git a/src/daemon/Display.h b/src/daemon/Display.h
index e68bc12..b4a1bf8 100644
--- a/src/daemon/Display.h
+++ b/src/daemon/Display.h
@@ -23,6 +23,7 @@
 #define SDDM_DISPLAY_H
 
 #include <QObject>
+#include <QPointer>
 #include <QDir>
 
 #include "Auth.h"
@@ -41,10 +42,19 @@ namespace SDDM {
         Q_OBJECT
         Q_DISABLE_COPY(Display)
     public:
-        explicit Display(int terminalId, Seat *parent);
+        enum DisplayServerType {
+            X11DisplayServerType,
+            X11UserDisplayServerType,
+            WaylandDisplayServerType
+        };
+        Q_ENUM(DisplayServerType)
+
+        explicit Display(Seat *parent);
         ~Display();
 
-        QString displayId() const;
+        DisplayServerType displayServerType() const;
+        DisplayServer *displayServer() const;
+
         const int terminalId() const;
 
         const QString &name() const;
@@ -76,12 +86,12 @@ namespace SDDM {
         void startAuth(const QString &user, const QString &password,
                        const Session &session);
 
+        DisplayServerType m_displayServerType = X11DisplayServerType;
+
         bool m_relogin { true };
         bool m_started { false };
 
-        int m_terminalId { 7 };
-
-        Session m_lastSession;
+        int m_terminalId = 0;
 
         QString m_passPhrase;
         QString m_sessionName;
@@ -91,7 +101,7 @@ namespace SDDM {
         DisplayServer *m_displayServer { nullptr };
         Seat *m_seat { nullptr };
         SocketServer *m_socketServer { nullptr };
-        QLocalSocket *m_socket { nullptr };
+        QPointer<QLocalSocket> m_socket;
         Greeter *m_greeter { nullptr };
 
     private slots:
diff --git a/src/daemon/Greeter.cpp b/src/daemon/Greeter.cpp
index 878576b..f7058f4 100644
--- a/src/daemon/Greeter.cpp
+++ b/src/daemon/Greeter.cpp
@@ -27,12 +27,17 @@
 #include "ThemeConfig.h"
 #include "ThemeMetadata.h"
 #include "Display.h"
+#include "XorgUserDisplayServer.h"
+#include "WaylandDisplayServer.h"
 
 #include <QtCore/QDebug>
 #include <QtCore/QProcess>
 
 namespace SDDM {
-    Greeter::Greeter(QObject *parent) : QObject(parent) {
+    Greeter::Greeter(Display *parent)
+        : QObject(parent)
+        , m_display(parent)
+    {
         m_metadata = new ThemeMetadata(QString());
         m_themeConfig = new ThemeConfig(QString());
     }
@@ -44,10 +49,6 @@ namespace SDDM {
         delete m_themeConfig;
     }
 
-    void Greeter::setDisplay(Display *display) {
-        m_display = display;
-    }
-
     void Greeter::setAuthPath(const QString &authPath) {
         m_authPath = authPath;
     }
@@ -71,6 +72,16 @@ namespace SDDM {
         }
     }
 
+    QString Greeter::displayServerCommand() const
+    {
+        return m_displayServerCmd;
+    }
+
+    void Greeter::setDisplayServerCommand(const QString &cmd)
+    {
+        m_displayServerCmd = cmd;
+    }
+
     bool Greeter::start() {
         // check flag
         if (m_started)
@@ -80,6 +91,9 @@ namespace SDDM {
         QString xcursorTheme = mainConfig.Theme.CursorTheme.get();
         if (m_themeConfig->contains(QLatin1String("cursorTheme")))
             xcursorTheme = m_themeConfig->value(QLatin1String("cursorTheme")).toString();
+        QString xcursorSize = mainConfig.Theme.CursorSize.get();
+        if (m_themeConfig->contains(QLatin1String("cursorSize")))
+            xcursorSize = m_themeConfig->value(QLatin1String("cursorSize")).toString();
         QString platformTheme;
         if (m_themeConfig->contains(QLatin1String("platformTheme")))
             platformTheme = m_themeConfig->value(QLatin1String("platformTheme")).toString();
@@ -98,6 +112,7 @@ namespace SDDM {
         if (!style.isEmpty())
             args << QLatin1String("-style") << style;
 
+        Q_ASSERT(m_display);
         if (daemonApp->testing()) {
             // create process
             m_process = new QProcess(this);
@@ -111,17 +126,19 @@ namespace SDDM {
             // log message
             qDebug() << "Greeter starting...";
 
-            // set process environment
-            QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
-            env.insert(QStringLiteral("DISPLAY"), m_display->name());
-            env.insert(QStringLiteral("XAUTHORITY"), m_authPath);
-            env.insert(QStringLiteral("XCURSOR_THEME"), xcursorTheme);
-            env.insert(QStringLiteral("QT_IM_MODULE"), mainConfig.InputMethod.get());
-            m_process->setProcessEnvironment(env);
-
-            // start greeter
-            if (daemonApp->testing())
-                args << QStringLiteral("--test-mode");
+            args << QStringLiteral("--test-mode");
+
+            if (m_display->displayServerType() == Display::X11DisplayServerType) {
+                // set process environment
+                QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
+                env.insert(QStringLiteral("DISPLAY"), m_display->name());
+                env.insert(QStringLiteral("XAUTHORITY"), m_authPath);
+                env.insert(QStringLiteral("XCURSOR_THEME"), xcursorTheme);
+                if (!xcursorSize.isEmpty())
+                    env.insert(QStringLiteral("XCURSOR_SIZE"), xcursorSize);
+                m_process->setProcessEnvironment(env);
+            }
+            // Greeter command
             m_process->start(QStringLiteral("%1/sddm-greeter").arg(QStringLiteral(BIN_INSTALL_DIR)), args);
 
             //if we fail to start bail immediately, and don't block in waitForStarted
@@ -149,11 +166,12 @@ namespace SDDM {
             m_auth->setVerbose(true);
             connect(m_auth, &Auth::requestChanged, this, &Greeter::onRequestChanged);
             connect(m_auth, &Auth::sessionStarted, this, &Greeter::onSessionStarted);
+            connect(m_auth, &Auth::displayServerReady, this, &Greeter::onDisplayServerReady);
             connect(m_auth, &Auth::finished, this, &Greeter::onHelperFinished);
             connect(m_auth, &Auth::info, this, &Greeter::authInfo);
             connect(m_auth, &Auth::error, this, &Greeter::authError);
 
-            // greeter command
+            // command
             QStringList cmd;
             cmd << QStringLiteral("%1/sddm-greeter").arg(QStringLiteral(BIN_INSTALL_DIR))
                 << args;
@@ -173,9 +191,9 @@ namespace SDDM {
             }, sysenv, env);
 
             env.insert(QStringLiteral("PATH"), mainConfig.Users.DefaultPath.get());
-            env.insert(QStringLiteral("DISPLAY"), m_display->name());
-            env.insert(QStringLiteral("XAUTHORITY"), m_authPath);
             env.insert(QStringLiteral("XCURSOR_THEME"), xcursorTheme);
+            if (!xcursorSize.isEmpty())
+                env.insert(QStringLiteral("XCURSOR_SIZE"), xcursorSize);
             env.insert(QStringLiteral("XDG_SEAT"), m_display->seat()->name());
             env.insert(QStringLiteral("XDG_SEAT_PATH"), daemonApp->displayManager()->seatPath(m_display->seat()->name()));
             env.insert(QStringLiteral("XDG_SESSION_PATH"), daemonApp->displayManager()->sessionPath(QStringLiteral("Session%1").arg(daemonApp->newSessionId())));
@@ -183,11 +201,15 @@ namespace SDDM {
                 env.insert(QStringLiteral("XDG_VTNR"), QString::number(m_display->terminalId()));
             env.insert(QStringLiteral("XDG_SESSION_CLASS"), QStringLiteral("greeter"));
             env.insert(QStringLiteral("XDG_SESSION_TYPE"), m_display->sessionType());
-            env.insert(QStringLiteral("QT_IM_MODULE"), mainConfig.InputMethod.get());
-
-            //some themes may use KDE components and that will automatically load KDE's crash handler which we don't want
-            //counterintuitively setting this env disables that handler
-            env.insert(QStringLiteral("KDE_DEBUG"), QStringLiteral("1"));
+            if (m_display->displayServerType() == Display::X11DisplayServerType) {
+                env.insert(QStringLiteral("DISPLAY"), m_display->name());
+                env.insert(QStringLiteral("XAUTHORITY"), m_authPath);
+                env.insert(QStringLiteral("QT_QPA_PLATFORM"), QStringLiteral("xcb"));
+            } else if (m_display->displayServerType() == Display::WaylandDisplayServerType) {
+                env.insert(QStringLiteral("QT_QPA_PLATFORM"), QStringLiteral("wayland"));
+                env.insert(QStringLiteral("QT_WAYLAND_DISABLE_WINDOWDECORATION"), QStringLiteral("1"));
+                env.insert(QStringLiteral("QT_WAYLAND_SHELL_INTEGRATION"), QStringLiteral("fullscreen-shell-v1"));
+            }
             m_auth->insertEnvironment(env);
 
             // log message
@@ -195,6 +217,7 @@ namespace SDDM {
 
             // start greeter
             m_auth->setUser(QStringLiteral("sddm"));
+            m_auth->setDisplayServerCommand(m_displayServerCmd);
             m_auth->setGreeter(true);
             m_auth->setSession(cmd.join(QLatin1Char(' ')));
             m_auth->start();
@@ -225,6 +248,8 @@ namespace SDDM {
             // wait for finished
             if (!m_process->waitForFinished(5000))
                 m_process->kill();
+        } else {
+            m_auth->stop();
         }
     }
 
@@ -240,8 +265,10 @@ namespace SDDM {
         qDebug() << "Greeter stopped.";
 
         // clean up
-        m_process->deleteLater();
-        m_process = nullptr;
+        if (m_process) {
+            m_process->deleteLater();
+            m_process = nullptr;
+        }
     }
 
     void Greeter::onRequestChanged() {
@@ -259,6 +286,19 @@ namespace SDDM {
             qDebug() << "Greeter session failed to start";
     }
 
+    void Greeter::onDisplayServerReady(const QString &displayName)
+    {
+        auto *displayServer = m_display->displayServer();
+
+        auto *xorgUser = qobject_cast<XorgUserDisplayServer *>(displayServer);
+        if (xorgUser)
+            xorgUser->setDisplayName(displayName);
+
+        auto *wayland = qobject_cast<WaylandDisplayServer *>(displayServer);
+        if (wayland)
+            wayland->setDisplayName(displayName);
+    }
+
     void Greeter::onHelperFinished(Auth::HelperExitStatus status) {
         // reset flag
         m_started = false;
@@ -269,6 +309,15 @@ namespace SDDM {
         // clean up
         m_auth->deleteLater();
         m_auth = nullptr;
+
+        if (status == Auth::HELPER_SESSION_ERROR) {
+            Q_EMIT failed();
+        }
+    }
+
+    bool Greeter::isRunning() const {
+        return (m_process && m_process->state() == QProcess::Running)
+            || (m_auth->isActive());
     }
 
     void Greeter::onReadyReadStandardError()
diff --git a/src/daemon/Greeter.h b/src/daemon/Greeter.h
index 7391a35..376ecdc 100644
--- a/src/daemon/Greeter.h
+++ b/src/daemon/Greeter.h
@@ -35,14 +35,17 @@ namespace SDDM {
         Q_OBJECT
         Q_DISABLE_COPY(Greeter)
     public:
-        explicit Greeter(QObject *parent = 0);
+        explicit Greeter(Display *parent = 0);
         ~Greeter();
 
-        void setDisplay(Display *display);
         void setAuthPath(const QString &authPath);
         void setSocket(const QString &socket);
         void setTheme(const QString &theme);
 
+        QString displayServerCommand() const;
+        void setDisplayServerCommand(const QString &cmd);
+        bool isRunning() const;
+
     public slots:
         bool start();
         void stop();
@@ -51,19 +54,24 @@ namespace SDDM {
     private slots:
         void onRequestChanged();
         void onSessionStarted(bool success);
+        void onDisplayServerReady(const QString &displayName);
         void onHelperFinished(Auth::HelperExitStatus status);
         void onReadyReadStandardOutput();
         void onReadyReadStandardError();
         void authInfo(const QString &message, Auth::Info info);
         void authError(const QString &message, Auth::Error error);
 
+    signals:
+        void failed();
+
     private:
         bool m_started { false };
 
-        Display *m_display { nullptr };
+        Display * const m_display { nullptr };
         QString m_authPath;
         QString m_socket;
         QString m_themePath;
+        QString m_displayServerCmd;
         ThemeMetadata *m_metadata { nullptr };
         ThemeConfig *m_themeConfig { nullptr };
 
diff --git a/src/daemon/PowerManager.cpp b/src/daemon/PowerManager.cpp
index 6eca29f..ab1d6ac 100644
--- a/src/daemon/PowerManager.cpp
+++ b/src/daemon/PowerManager.cpp
@@ -87,11 +87,15 @@ const QString UPOWER_OBJECT = QStringLiteral("org.freedesktop.UPower");
         }
 
         void powerOff() const {
-            QProcess::execute(mainConfig.HaltCommand.get());
+            auto command = QProcess::splitCommand(mainConfig.HaltCommand.get());
+            const QString program = command.takeFirst();
+            QProcess::execute(program, command);
         }
 
         void reboot() const {
-            QProcess::execute(mainConfig.RebootCommand.get());
+            auto command = QProcess::splitCommand(mainConfig.RebootCommand.get());
+            const QString program = command.takeFirst();
+            QProcess::execute(program, command);
         }
 
         void suspend() const {
diff --git a/src/daemon/Seat.cpp b/src/daemon/Seat.cpp
index eef26da..76e7507 100644
--- a/src/daemon/Seat.cpp
+++ b/src/daemon/Seat.cpp
@@ -28,22 +28,11 @@
 
 #include <QDebug>
 #include <QFile>
+#include <QTimer>
 
 #include <functional>
 
 namespace SDDM {
-    int findUnused(int minimum, std::function<bool(const int)> used) {
-        // initialize with minimum
-        int number = minimum;
-
-        // find unused
-        while (used(number))
-            number++;
-
-        // return number;
-        return number;
-    }
-
     Seat::Seat(const QString &name, QObject *parent) : QObject(parent), m_name(name) {
         createDisplay();
     }
@@ -52,30 +41,13 @@ namespace SDDM {
         return m_name;
     }
 
-    bool Seat::createDisplay(int terminalId) {
+    void Seat::createDisplay() {
         //reload config if needed
         mainConfig.load();
 
-        if (m_name == QLatin1String("seat0")) {
-            if (terminalId == -1) {
-                // find unused terminal
-                terminalId = findUnused(mainConfig.X11.MinimumVT.get(), [&](const int number) {
-                    return m_terminalIds.contains(number);
-                });
-            }
-
-            // mark terminal as used
-            m_terminalIds << terminalId;
-
-            // log message
-            qDebug() << "Adding new display" << "on vt" << terminalId << "...";
-        }
-        else {
-            qDebug() << "Adding new VT-less display...";
-        }
-
         // create a new display
-        Display *display = new Display(terminalId, this);
+        qDebug() << "Adding new display...";
+        Display *display = new Display(this);
 
         // restart display on stop
         connect(display, &Display::stopped, this, &Seat::displayStopped);
@@ -84,24 +56,33 @@ namespace SDDM {
         m_displays << display;
 
         // start the display
-        if (!display->start()) {
-            qCritical() << "Could not start Display server on vt" << terminalId;
-            return false;
+        startDisplay(display);
+    }
+
+    void Seat::startDisplay(Display *display, int tryNr) {
+        if (display->start())
+            return;
+
+        // It's possible that the system isn't ready yet (driver not loaded,
+        // device not enumerated, ...). It's not possible to tell when that changes,
+        // so try a few times with a delay in between.
+        qWarning() << "Attempt" << tryNr << "starting the Display server on vt" << display->terminalId() << "failed";
+
+        if(tryNr >= 3) {
+            qCritical() << "Could not start Display server on vt" << display->terminalId();
+            return;
         }
 
-        return true;
+        QTimer::singleShot(2000, display, [=] { startDisplay(display, tryNr + 1); });
     }
 
     void Seat::removeDisplay(Display* display) {
-        qDebug() << "Removing display" << display->displayId() << "...";
+        qDebug() << "Removing display" << display << "...";
 
 
         // remove display from list
         m_displays.removeAll(display);
 
-        // mark display and terminal ids as unused
-        m_terminalIds.removeAll(display->terminalId());
-
         // stop the display
         display->blockSignals(true);
         display->stop();
diff --git a/src/daemon/Seat.h b/src/daemon/Seat.h
index bf22566..685eaed 100644
--- a/src/daemon/Seat.h
+++ b/src/daemon/Seat.h
@@ -35,17 +35,18 @@ namespace SDDM {
         const QString &name() const;
 
     public slots:
-        bool createDisplay(int terminalId = -1);
+        void createDisplay();
         void removeDisplay(SDDM::Display* display);
 
     private slots:
         void displayStopped();
 
     private:
+        void startDisplay(SDDM::Display *display, int tryNr = 1);
+
         QString m_name;
 
         QVector<Display *> m_displays;
-        QVector<int> m_terminalIds;
     };
 }
 
diff --git a/src/daemon/SocketServer.h b/src/daemon/SocketServer.h
index 0d12acb..81502b4 100644
--- a/src/daemon/SocketServer.h
+++ b/src/daemon/SocketServer.h
@@ -45,6 +45,7 @@ namespace SDDM {
         void newConnection();
         void readyRead();
 
+    public slots:
         void loginFailed(QLocalSocket *socket);
         void loginSucceeded(QLocalSocket *socket);
 
diff --git a/src/daemon/Utils.h b/src/daemon/Utils.h
index 7de5a98..03170f8 100644
--- a/src/daemon/Utils.h
+++ b/src/daemon/Utils.h
@@ -26,11 +26,11 @@
 namespace SDDM {
 
 inline QString generateName(int length) {
-    QString digits = QStringLiteral("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
+    const QString digits = QStringLiteral("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
 
     // reserve space for name
     QString name;
-    name.reserve(length);
+    name.resize(length);
 
     // create random device
     std::random_device rd;
diff --git a/src/daemon/WaylandDisplayServer.cpp b/src/daemon/WaylandDisplayServer.cpp
new file mode 100644
index 0000000..02f2689
--- /dev/null
+++ b/src/daemon/WaylandDisplayServer.cpp
@@ -0,0 +1,76 @@
+/***************************************************************************
+* Copyright (c) 2021 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#include "WaylandDisplayServer.h"
+
+namespace SDDM {
+
+WaylandDisplayServer::WaylandDisplayServer(Display *parent)
+    : DisplayServer(parent)
+{
+}
+
+WaylandDisplayServer::~WaylandDisplayServer()
+{
+    stop();
+}
+
+QString WaylandDisplayServer::sessionType() const
+{
+    return QStringLiteral("wayland");
+}
+
+void WaylandDisplayServer::setDisplayName(const QString &displayName)
+{
+    m_display = displayName;
+}
+
+bool WaylandDisplayServer::start()
+{
+    // Check flag
+    if (m_started)
+        return false;
+
+    // Set flag
+    m_started = true;
+    emit started();
+
+    return true;
+}
+
+void WaylandDisplayServer::stop()
+{
+    // Check flag
+    if (!m_started)
+        return;
+
+    // Reset flag
+    m_started = false;
+    emit stopped();
+}
+
+void WaylandDisplayServer::finished()
+{
+}
+
+void WaylandDisplayServer::setupDisplay()
+{
+}
+
+} // namespace SDDM
diff --git a/src/daemon/WaylandDisplayServer.h b/src/daemon/WaylandDisplayServer.h
new file mode 100644
index 0000000..a8d9826
--- /dev/null
+++ b/src/daemon/WaylandDisplayServer.h
@@ -0,0 +1,48 @@
+/***************************************************************************
+* Copyright (c) 2021 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#ifndef SDDM_WAYLANDDISPLAYSERVER_H
+#define SDDM_WAYLANDDISPLAYSERVER_H
+
+#include "DisplayServer.h"
+
+namespace SDDM {
+
+class WaylandDisplayServer : public DisplayServer
+{
+    Q_OBJECT
+    Q_DISABLE_COPY(WaylandDisplayServer)
+public:
+    explicit WaylandDisplayServer(Display *parent);
+    ~WaylandDisplayServer();
+
+    QString sessionType() const;
+
+    void setDisplayName(const QString &displayName);
+
+public Q_SLOTS:
+    bool start();
+    void stop();
+    void finished();
+    void setupDisplay();
+};
+
+} // namespace SDDM
+
+#endif // SDDM_WAYLANDDISPLAYSERVER_H
diff --git a/src/daemon/XorgDisplayServer.cpp b/src/daemon/XorgDisplayServer.cpp
index 5f93a1b..543b112 100644
--- a/src/daemon/XorgDisplayServer.cpp
+++ b/src/daemon/XorgDisplayServer.cpp
@@ -23,7 +23,6 @@
 #include "Configuration.h"
 #include "DaemonApp.h"
 #include "Display.h"
-#include "SignalHandler.h"
 #include "Seat.h"
 
 #include <QDebug>
@@ -41,31 +40,9 @@
 
 namespace SDDM {
     XorgDisplayServer::XorgDisplayServer(Display *parent) : DisplayServer(parent) {
-        // get auth directory
-        QString authDir = QStringLiteral(RUNTIME_DIR);
-
-        // use "." as authdir in test mode
         if (daemonApp->testing())
-            authDir = QStringLiteral(".");
-
-        // create auth dir if not existing
-        QDir().mkpath(authDir);
-
-        // set auth path
-        m_authPath = QStringLiteral("%1/%2").arg(authDir).arg(QUuid::createUuid().toString());
-
-        // generate cookie
-        std::random_device rd;
-        std::mt19937 gen(rd());
-        std::uniform_int_distribution<> dis(0, 15);
-
-        // resever 32 bytes
-        m_cookie.reserve(32);
-
-        // create a random hexadecimal number
-        const char *digits = "0123456789abcdef";
-        for (int i = 0; i < 32; ++i)
-            m_cookie[i] = digits[dis(gen)];
+            m_xauth.setAuthDirectory(QStringLiteral("."));
+        m_xauth.setup();
     }
 
     XorgDisplayServer::~XorgDisplayServer() {
@@ -76,41 +53,16 @@ namespace SDDM {
         return m_display;
     }
 
-    const QString &XorgDisplayServer::authPath() const {
-        return m_authPath;
+    QString XorgDisplayServer::authPath() const {
+        return m_xauth.authPath();
     }
 
     QString XorgDisplayServer::sessionType() const {
         return QStringLiteral("x11");
     }
 
-    const QString &XorgDisplayServer::cookie() const {
-        return m_cookie;
-    }
-
-    bool XorgDisplayServer::addCookie(const QString &file) {
-        // log message
-        qDebug() << "Adding cookie to" << file;
-
-        // Touch file
-        QFile file_handler(file);
-        file_handler.open(QIODevice::Append);
-        file_handler.close();
-
-        QString cmd = QStringLiteral("%1 -f %2 -q").arg(mainConfig.X11.XauthPath.get()).arg(file);
-
-        // execute xauth
-        FILE *fp = popen(qPrintable(cmd), "w");
-
-        // check file
-        if (!fp)
-            return false;
-        fprintf(fp, "remove %s\n", qPrintable(m_display));
-        fprintf(fp, "add %s . %s\n", qPrintable(m_display), qPrintable(m_cookie));
-        fprintf(fp, "exit\n");
-
-        // close pipe
-        return pclose(fp) == 0;
+    QString XorgDisplayServer::cookie() const {
+        return m_xauth.cookie();
     }
 
     bool XorgDisplayServer::start() {
@@ -118,6 +70,11 @@ namespace SDDM {
         if (m_started)
             return false;
 
+        if (process) {
+            qCritical() << "Tried to start Xorg before previous instance exited";
+            return false;
+        }
+
         // create process
         process = new QProcess(this);
 
@@ -131,110 +88,98 @@ namespace SDDM {
         // For the X server's copy, the display number doesn't matter.
         // An empty file would result in no access control!
         m_display = QStringLiteral(":0");
-        if(!addCookie(m_authPath)) {
+        if(!m_xauth.addCookie(m_display)) {
             qCritical() << "Failed to write xauth file";
             return false;
         }
 
-        if (daemonApp->testing()) {
-            QStringList args;
-            QDir x11socketDir(QStringLiteral("/tmp/.X11-unix"));
-            int display = 100;
-            while (x11socketDir.exists(QStringLiteral("X%1").arg(display))) {
-                ++display;
-            }
-            m_display = QStringLiteral(":%1").arg(display);
-            args << m_display << QStringLiteral("-auth") << m_authPath << QStringLiteral("-br") << QStringLiteral("-noreset") << QStringLiteral("-screen") << QStringLiteral("800x600");
-            process->start(mainConfig.X11.XephyrPath.get(), args);
-
+        // set process environment
+        QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
+        env.insert(QStringLiteral("XCURSOR_THEME"), mainConfig.Theme.CursorTheme.get());
+        process->setProcessEnvironment(env);
 
-            // wait for display server to start
-            if (!process->waitForStarted()) {
-                // log message
-                qCritical() << "Failed to start display server process.";
+        //create pipe for communicating with X server
+        //0 == read from X, 1== write to from X
+        int pipeFds[2];
+        if (pipe(pipeFds) != 0) {
+            qCritical("Could not create pipe to start X server");
+        }
 
-                // return fail
-                return false;
-            }
-            emit started();
+        // start display server
+        QStringList args;
+        if (!daemonApp->testing()) {
+            process->setProgram(mainConfig.X11.ServerPath.get());
+            args << mainConfig.X11.ServerArguments.get().split(QLatin1Char(' '), Qt::SkipEmptyParts)
+                 << QStringLiteral("-background") << QStringLiteral("none")
+                 << QStringLiteral("-seat") << displayPtr()->seat()->name()
+                 << QStringLiteral("vt%1").arg(displayPtr()->terminalId());
         } else {
-            // set process environment
-            QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
-            env.insert(QStringLiteral("XCURSOR_THEME"), mainConfig.Theme.CursorTheme.get());
-            process->setProcessEnvironment(env);
-
-            //create pipe for communicating with X server
-            //0 == read from X, 1== write to from X
-            int pipeFds[2];
-            if (pipe(pipeFds) != 0) {
-                qCritical("Could not create pipe to start X server");
-            }
+            process->setProgram(mainConfig.X11.XephyrPath.get());
+            args << QStringLiteral("-br")
+                 << QStringLiteral("-screen") << QStringLiteral("800x600");
+        }
 
-            // start display server
-            QStringList args = mainConfig.X11.ServerArguments.get().split(QLatin1Char(' '), QString::SkipEmptyParts);
-            args << QStringLiteral("-auth") << m_authPath
-                 << QStringLiteral("-background") << QStringLiteral("none")
-                 << QStringLiteral("-noreset")
-                 << QStringLiteral("-displayfd") << QString::number(pipeFds[1])
-                 << QStringLiteral("-seat") << displayPtr()->seat()->name();
+        args << QStringLiteral("-auth") << m_xauth.authPath()
+             << QStringLiteral("-noreset")
+             << QStringLiteral("-displayfd") << QString::number(pipeFds[1]);
 
-            if (displayPtr()->seat()->name() == QLatin1String("seat0")) {
-                args << QStringLiteral("vt%1").arg(displayPtr()->terminalId());
-            }
-            qDebug() << "Running:"
-                     << qPrintable(mainConfig.X11.ServerPath.get())
-                     << qPrintable(args.join(QLatin1Char(' ')));
-            process->start(mainConfig.X11.ServerPath.get(), args);
-
-            // wait for display server to start
-            if (!process->waitForStarted()) {
-                // log message
-                qCritical() << "Failed to start display server process.";
-
-                // return fail
-                close(pipeFds[0]);
-                return false;
-            }
+        process->setArguments(args);
+        qDebug() << "Running:"
+            << qPrintable(process->program())
+            << qPrintable(process->arguments().join(QLatin1Char(' ')));
+        process->start();
 
-            // close the other side of pipe in our process, otherwise reading
-            // from it may stuck even X server exit.
-            close(pipeFds[1]);
+        // wait for display server to start
+        if (!process->waitForStarted()) {
+            // log message
+            qCritical() << "Failed to start display server process.";
 
-            QFile readPipe;
+            // return fail
+            close(pipeFds[0]);
+            return false;
+        }
 
-            if (!readPipe.open(pipeFds[0], QIODevice::ReadOnly)) {
-                qCritical("Failed to open pipe to start X Server");
+        // close the other side of pipe in our process, otherwise reading
+        // from it may stuck even X server exit.
+        close(pipeFds[1]);
 
-                close(pipeFds[0]);
-                return false;
-            }
-            QByteArray displayNumber = readPipe.readLine();
-            if (displayNumber.size() < 2) {
-                // X server gave nothing (or a whitespace).
-                qCritical("Failed to read display number from pipe");
+        QFile readPipe;
 
-                close(pipeFds[0]);
-                return false;
-            }
-            displayNumber.prepend(QByteArray(":"));
-            displayNumber.remove(displayNumber.size() -1, 1); // trim trailing whitespace
-            m_display = QString::fromLocal8Bit(displayNumber);
+        if (!readPipe.open(pipeFds[0], QIODevice::ReadOnly)) {
+            qCritical("Failed to open pipe to start X Server");
 
-            // close our pipe
             close(pipeFds[0]);
+            stop();
+            return false;
+        }
+        QByteArray displayNumber = readPipe.readLine();
+        if (displayNumber.size() < 2) {
+            // X server gave nothing (or a whitespace).
+            qCritical("Failed to read display number from pipe");
 
-            emit started();
+            close(pipeFds[0]);
+            stop();
+            return false;
         }
+        displayNumber.prepend(QByteArray(":"));
+        displayNumber.remove(displayNumber.size() -1, 1); // trim trailing whitespace
+        m_display = QString::fromLocal8Bit(displayNumber);
+
+        // close our pipe
+        close(pipeFds[0]);
 
         // The file is also used by the greeter, which does care about the
         // display number. Write the proper entry, if it's different.
         if(m_display != QStringLiteral(":0")) {
-            if(!addCookie(m_authPath)) {
+            if(!m_xauth.addCookie(m_display)) {
                 qCritical() << "Failed to write xauth file";
+                stop();
                 return false;
             }
         }
-        changeOwner(m_authPath);
+        changeOwner(m_xauth.authPath());
+
+        emit started();
 
         // set flag
         m_started = true;
@@ -244,8 +189,7 @@ namespace SDDM {
     }
 
     void XorgDisplayServer::stop() {
-        // check flag
-        if (!m_started)
+        if (!process)
             return;
 
         // log message
@@ -260,6 +204,12 @@ namespace SDDM {
     }
 
     void XorgDisplayServer::finished() {
+        // clean up
+        if (process) {
+            process->deleteLater();
+            process = nullptr;
+        }
+
         // check flag
         if (!m_started)
             return;
@@ -270,7 +220,7 @@ namespace SDDM {
         // log message
         qDebug() << "Display server stopped.";
 
-        QString displayStopCommand = mainConfig.X11.DisplayStopCommand.get();
+        QStringList displayStopCommand = QProcess::splitCommand(mainConfig.X11.DisplayStopCommand.get());
 
         // create display setup script process
         QProcess *displayStopScript = new QProcess();
@@ -285,7 +235,8 @@ namespace SDDM {
 
         // start display stop script
         qDebug() << "Running display stop script " << displayStopCommand;
-        displayStopScript->start(displayStopCommand);
+        const auto program = displayStopCommand.takeFirst();
+        displayStopScript->start(program, displayStopCommand);
 
         // wait for finished
         if (!displayStopScript->waitForFinished(5000))
@@ -295,20 +246,14 @@ namespace SDDM {
         displayStopScript->deleteLater();
         displayStopScript = nullptr;
 
-        // clean up
-        process->deleteLater();
-        process = nullptr;
-
         // remove authority file
-        QFile::remove(m_authPath);
+        QFile::remove(m_xauth.authPath());
 
         // emit signal
         emit stopped();
     }
 
     void XorgDisplayServer::setupDisplay() {
-        QString displayCommand = mainConfig.X11.DisplayCommand.get();
-
         // create cursor setup process
         QProcess *setCursor = new QProcess();
         // create display setup script process
@@ -319,14 +264,14 @@ namespace SDDM {
         env.insert(QStringLiteral("DISPLAY"), m_display);
         env.insert(QStringLiteral("HOME"), QStringLiteral("/"));
         env.insert(QStringLiteral("PATH"), mainConfig.Users.DefaultPath.get());
-        env.insert(QStringLiteral("XAUTHORITY"), m_authPath);
+        env.insert(QStringLiteral("XAUTHORITY"), m_xauth.authPath());
         env.insert(QStringLiteral("SHELL"), QStringLiteral("/bin/sh"));
         env.insert(QStringLiteral("XCURSOR_THEME"), mainConfig.Theme.CursorTheme.get());
         setCursor->setProcessEnvironment(env);
         displayScript->setProcessEnvironment(env);
 
         qDebug() << "Setting default cursor";
-        setCursor->start(QStringLiteral("xsetroot -cursor_name left_ptr"));
+        setCursor->start(QStringLiteral("xsetroot"), { QStringLiteral("-cursor_name"), QStringLiteral("left_ptr") });
 
         // delete setCursor on finish
         connect(setCursor, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished), setCursor, &QProcess::deleteLater);
@@ -338,8 +283,10 @@ namespace SDDM {
         }
 
         // start display setup script
-        qDebug() << "Running display setup script " << displayCommand;
-        displayScript->start(displayCommand);
+        qDebug() << "Running display setup script " << mainConfig.X11.DisplayCommand.get();
+        QStringList displayCommand = QProcess::splitCommand(mainConfig.X11.DisplayCommand.get());
+        const QString program = displayCommand.takeFirst();
+        displayScript->start(program, displayCommand);
 
         // delete displayScript on finish
         connect(displayScript, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished), displayScript, &QProcess::deleteLater);
diff --git a/src/daemon/XorgDisplayServer.h b/src/daemon/XorgDisplayServer.h
index e97a0b5..ebf1899 100644
--- a/src/daemon/XorgDisplayServer.h
+++ b/src/daemon/XorgDisplayServer.h
@@ -22,6 +22,7 @@
 #define SDDM_XORGDISPLAYSERVER_H
 
 #include "DisplayServer.h"
+#include "XAuth.h"
 
 class QProcess;
 
@@ -34,13 +35,11 @@ namespace SDDM {
         ~XorgDisplayServer();
 
         const QString &display() const;
-        const QString &authPath() const;
+        QString authPath() const;
 
         QString sessionType() const;
 
-        const QString &cookie() const;
-
-        bool addCookie(const QString &file);
+        QString cookie() const;
 
     public slots:
         bool start();
@@ -49,8 +48,7 @@ namespace SDDM {
         void setupDisplay();
 
     private:
-        QString m_authPath;
-        QString m_cookie;
+        XAuth m_xauth;
 
         QProcess *process { nullptr };
 
diff --git a/src/daemon/XorgUserDisplayServer.cpp b/src/daemon/XorgUserDisplayServer.cpp
new file mode 100644
index 0000000..1e7c008
--- /dev/null
+++ b/src/daemon/XorgUserDisplayServer.cpp
@@ -0,0 +1,102 @@
+/***************************************************************************
+* Copyright (c) 2021 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#include "Configuration.h"
+#include "DaemonApp.h"
+#include "Display.h"
+#include "Seat.h"
+#include "XorgUserDisplayServer.h"
+
+namespace SDDM {
+
+XorgUserDisplayServer::XorgUserDisplayServer(Display *parent)
+    : DisplayServer(parent)
+{
+}
+
+XorgUserDisplayServer::~XorgUserDisplayServer()
+{
+    stop();
+}
+
+QString XorgUserDisplayServer::sessionType() const
+{
+    return QStringLiteral("x11");
+}
+
+void XorgUserDisplayServer::setDisplayName(const QString &displayName)
+{
+    m_display = displayName;
+}
+
+QString XorgUserDisplayServer::command(Display *display)
+{
+    QStringList args;
+
+    if (daemonApp->testing()) {
+        args << mainConfig.X11.XephyrPath.get()
+             << QStringLiteral("-br")
+             << QStringLiteral("-screen") << QStringLiteral("800x600");
+    } else {
+        args << mainConfig.X11.ServerPath.get()
+             << mainConfig.X11.ServerArguments.get().split(QLatin1Char(' '), Qt::SkipEmptyParts)
+             << QStringLiteral("-background") << QStringLiteral("none")
+             << QStringLiteral("-seat") << display->seat()->name()
+             << QStringLiteral("-noreset")
+             << QStringLiteral("-keeptty")
+             << QStringLiteral("-novtswitch")
+             << QStringLiteral("-verbose") << QStringLiteral("3");
+    }
+
+    return args.join(QLatin1Char(' '));
+}
+
+bool XorgUserDisplayServer::start()
+{
+    // Check flag
+    if (m_started)
+        return false;
+
+    // Set flag
+    m_started = true;
+    emit started();
+
+    return true;
+}
+
+void XorgUserDisplayServer::stop()
+{
+    // Check flag
+    if (!m_started)
+        return;
+
+    // Reset flag
+    m_started = false;
+    emit stopped();
+}
+
+void XorgUserDisplayServer::finished()
+{
+}
+
+void XorgUserDisplayServer::setupDisplay()
+{
+}
+
+} // namespace SDDM
diff --git a/src/daemon/XorgUserDisplayServer.h b/src/daemon/XorgUserDisplayServer.h
new file mode 100644
index 0000000..aa7cbe4
--- /dev/null
+++ b/src/daemon/XorgUserDisplayServer.h
@@ -0,0 +1,53 @@
+/***************************************************************************
+* Copyright (c) 2021 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#ifndef SDDM_XORGUSERDISPLAYSERVER_H
+#define SDDM_XORGUSERDISPLAYSERVER_H
+
+#include "DisplayServer.h"
+#include "XAuth.h"
+
+class QProcess;
+
+namespace SDDM {
+
+class XorgUserDisplayServer : public DisplayServer
+{
+    Q_OBJECT
+    Q_DISABLE_COPY(XorgUserDisplayServer)
+public:
+    explicit XorgUserDisplayServer(Display *parent);
+    ~XorgUserDisplayServer();
+
+    QString sessionType() const;
+
+    void setDisplayName(const QString &displayName);
+
+    static QString command(Display *display);
+
+public Q_SLOTS:
+    bool start();
+    void stop();
+    void finished();
+    void setupDisplay();
+};
+
+} // namespace SDDM
+
+#endif // SDDM_XORGUSERDISPLAYSERVER_H
diff --git a/src/greeter/CMakeLists.txt b/src/greeter/CMakeLists.txt
index 2752964..1bfa49a 100644
--- a/src/greeter/CMakeLists.txt
+++ b/src/greeter/CMakeLists.txt
@@ -18,6 +18,8 @@ set(GREETER_SOURCES
     ScreenModel.cpp
     SessionModel.cpp
     UserModel.cpp
+    waylandkeyboardbackend.cpp
+    waylandkeyboardbackend.h
     XcbKeyboardBackend.cpp
 )
 
diff --git a/src/greeter/GreeterApp.cpp b/src/greeter/GreeterApp.cpp
index bbce512..7abfcd8 100644
--- a/src/greeter/GreeterApp.cpp
+++ b/src/greeter/GreeterApp.cpp
@@ -149,6 +149,7 @@ namespace SDDM {
         view->setResizeMode(QQuickView::SizeRootObjectToView);
         //view->setGeometry(QRect(QPoint(0, 0), screen->geometry().size()));
         view->setGeometry(screen->geometry());
+        view->setFlags(Qt::FramelessWindowHint);
         m_views.append(view);
 
         // remove the view when the screen is removed, but we
@@ -258,10 +259,13 @@ namespace SDDM {
         }
 
         // Set font
-        QVariant fontEntry = mainConfig.Theme.Font.get();
-        QFont font = fontEntry.value<QFont>();
-        if (!fontEntry.toString().isEmpty())
-            QGuiApplication::setFont(font);
+        const QString fontStr = mainConfig.Theme.Font.get();
+        if (!fontStr.isEmpty()) {
+            QFont font;
+            if (font.fromString(fontStr)) {
+                QGuiApplication::setFont(font);
+            }
+        }
 
         // Set session model on proxy
         m_proxy->setSessionModel(m_sessionModel);
@@ -334,6 +338,15 @@ int main(int argc, char **argv)
         QSurfaceFormat::setDefaultFormat(format);
     }
 
+    // Some themes may use KDE components and that will automatically load KDE's
+    // crash handler which we don't want counterintuitively setting this env
+    // disables that handler
+    qputenv("KDE_DEBUG", "1");
+
+    // Qt IM module
+    if (!SDDM::mainConfig.InputMethod.get().isEmpty())
+        qputenv("QT_IM_MODULE", SDDM::mainConfig.InputMethod.get().toLocal8Bit().constData());
+
     QGuiApplication app(argc, argv);
 
     QCommandLineParser parser;
diff --git a/src/greeter/GreeterProxy.cpp b/src/greeter/GreeterProxy.cpp
index 8fde3d9..d6e62cc 100644
--- a/src/greeter/GreeterProxy.cpp
+++ b/src/greeter/GreeterProxy.cpp
@@ -46,7 +46,7 @@ namespace SDDM {
         connect(d->socket, &QLocalSocket::connected, this, &GreeterProxy::connected);
         connect(d->socket, &QLocalSocket::disconnected, this, &GreeterProxy::disconnected);
         connect(d->socket, &QLocalSocket::readyRead, this, &GreeterProxy::readyRead);
-        connect(d->socket, QOverload<QLocalSocket::LocalSocketError>::of(&QLocalSocket::error), this, &GreeterProxy::error);
+        connect(d->socket, &QLocalSocket::errorOccurred, this, &GreeterProxy::error);
 
         // connect to server
         d->socket->connectToServer(socket);
diff --git a/src/greeter/KeyboardModel.cpp b/src/greeter/KeyboardModel.cpp
index 7d40441..6ebfefb 100644
--- a/src/greeter/KeyboardModel.cpp
+++ b/src/greeter/KeyboardModel.cpp
@@ -1,4 +1,5 @@
 /***************************************************************************
+* Copyright (c) 2021 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
 * Copyright (c) 2013 Nikita Mikhaylov <nslqqq@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
@@ -17,8 +18,11 @@
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 ***************************************************************************/
 
+#include <QGuiApplication>
+
 #include "KeyboardModel.h"
 #include "KeyboardModel_p.h"
+#include "waylandkeyboardbackend.h"
 #include "XcbKeyboardBackend.h"
 
 namespace SDDM {
@@ -27,14 +31,21 @@ namespace SDDM {
     /**********************************************/
 
     KeyboardModel::KeyboardModel() : d(new KeyboardModelPrivate) {
-        m_backend = new XcbKeyboardBackend(d);
-        m_backend->init();
-        m_backend->connectEventsDispatcher(this);
+        if (QGuiApplication::platformName() == QLatin1String("xcb")) {
+            m_backend = new XcbKeyboardBackend(d);
+            m_backend->init();
+            m_backend->connectEventsDispatcher(this);
+        } else if (QGuiApplication::platformName().contains(QLatin1String("wayland"))) {
+            m_backend = new WaylandKeyboardBackend(d);
+            m_backend->init();
+        }
     }
 
     KeyboardModel::~KeyboardModel() {
-        m_backend->disconnect();
-        delete m_backend;
+        if (m_backend) {
+            m_backend->disconnect();
+            delete m_backend;
+        }
 
         for (QObject *layout: d->layouts) {
             delete layout;
@@ -49,7 +60,8 @@ namespace SDDM {
     void KeyboardModel::setNumLockState(bool state) {
         if (d->numlock.enabled != state) {
             d->numlock.enabled = state;
-            m_backend->sendChanges();
+            if (m_backend)
+                m_backend->sendChanges();
 
             emit numLockStateChanged();
         }
@@ -62,7 +74,8 @@ namespace SDDM {
     void KeyboardModel::setCapsLockState(bool state) {
         if (d->capslock.enabled != state) {
             d->capslock.enabled = state;
-            m_backend->sendChanges();
+            if (m_backend)
+                m_backend->sendChanges();
 
             emit capsLockStateChanged();
         }
@@ -79,7 +92,8 @@ namespace SDDM {
     void KeyboardModel::setCurrentLayout(int id) {
         if (d->layout_id != id) {
             d->layout_id = id;
-            m_backend->sendChanges();
+            if (m_backend)
+                m_backend->sendChanges();
 
             emit currentLayoutChanged();
         }
@@ -96,7 +110,8 @@ namespace SDDM {
         QList<QObject*> layouts_old = d->layouts;
 
         // Process events
-        m_backend->dispatchEvents();
+        if (m_backend)
+            m_backend->dispatchEvents();
 
         // Send updates
         if (caps_old != d->capslock.enabled)
diff --git a/src/greeter/KeyboardModel.h b/src/greeter/KeyboardModel.h
index ca57849..26cb4d4 100644
--- a/src/greeter/KeyboardModel.h
+++ b/src/greeter/KeyboardModel.h
@@ -71,7 +71,7 @@ namespace SDDM {
 
     private:
         KeyboardModelPrivate * d { nullptr };
-        KeyboardBackend * m_backend;
+        KeyboardBackend * m_backend = nullptr;
     };
 }
 
diff --git a/src/greeter/ScreenModel.h b/src/greeter/ScreenModel.h
index 16284f2..1771e0b 100644
--- a/src/greeter/ScreenModel.h
+++ b/src/greeter/ScreenModel.h
@@ -40,6 +40,7 @@ namespace SDDM {
             NameRole = Qt::UserRole + 1,
             GeometryRole
         };
+        Q_ENUM(ScreenRoles)
 
         ScreenModel(QScreen *screen, QObject *parent = 0);
         ~ScreenModel();
diff --git a/src/greeter/SessionModel.cpp b/src/greeter/SessionModel.cpp
index 1953c76..a0eb3b1 100644
--- a/src/greeter/SessionModel.cpp
+++ b/src/greeter/SessionModel.cpp
@@ -35,6 +35,7 @@ namespace SDDM {
         }
 
         int lastIndex { 0 };
+        QStringList displayNames;
         QVector<Session *> sessions;
     };
 
@@ -50,6 +51,7 @@ namespace SDDM {
         connect(watcher, &QFileSystemWatcher::directoryChanged, [this](const QString &path) {
             beginResetModel();
             d->sessions.clear();
+            d->displayNames.clear();
             populate(Session::WaylandSession, mainConfig.Wayland.SessionDir.get());
             populate(Session::X11Session, mainConfig.X11.SessionDir.get());
             endResetModel();
@@ -99,6 +101,8 @@ namespace SDDM {
         case TypeRole:
             return session->type();
         case NameRole:
+            if (d->displayNames.count(session->displayName()) > 1 && session->type() == Session::WaylandSession)
+                return tr("%1 (Wayland)").arg(session->displayName());
             return session->displayName();
         case ExecRole:
             return session->exec();
@@ -144,10 +148,12 @@ namespace SDDM {
                 }
             }
             // add to sessions list
-            if (!si->isHidden() && !si->isNoDisplay() && execAllowed)
+            if (!si->isHidden() && !si->isNoDisplay() && execAllowed) {
+                d->displayNames.append(si->displayName());
                 d->sessions.push_back(si);
-            else
+            } else {
                 delete si;
+            }
         }
         // find out index of the last session
         for (int i = 0; i < d->sessions.size(); ++i) {
diff --git a/src/greeter/SessionModel.h b/src/greeter/SessionModel.h
index 2e2efa9..e11f35a 100644
--- a/src/greeter/SessionModel.h
+++ b/src/greeter/SessionModel.h
@@ -43,6 +43,7 @@ namespace SDDM {
             ExecRole,
             CommentRole
         };
+        Q_ENUM(SessionRole)
 
         SessionModel(QObject *parent = 0);
         ~SessionModel();
diff --git a/src/greeter/UserModel.cpp b/src/greeter/UserModel.cpp
index 7d7f9e2..5b92df5 100644
--- a/src/greeter/UserModel.cpp
+++ b/src/greeter/UserModel.cpp
@@ -136,14 +136,20 @@ namespace SDDM {
             if (avatarsEnabled) {
                 const QString userFace = QStringLiteral("%1/.face.icon").arg(user->homeDir);
                 const QString systemFace = QStringLiteral("%1/%2.face.icon").arg(facesDir).arg(user->name);
-                QString accountsServiceFace = QStringLiteral("/var/lib/AccountsService/icons/%1").arg(user->name);
-
-                if (QFile::exists(userFace))
-                    user->icon = QStringLiteral("file://%1").arg(userFace);
+                const QString accountsServiceFace = QStringLiteral("/var/lib/AccountsService/icons/%1").arg(user->name);
+
+                QString userIcon;
+                // If the home is encrypted it takes a lot of time to open
+                // up the greeter, therefore we try the system avatar first
+                if (QFile::exists(systemFace))
+                    userIcon = systemFace;
+                else if (QFile::exists(userFace))
+                    userIcon = userFace;
                 else if (QFile::exists(accountsServiceFace))
-                    user->icon = accountsServiceFace;
-                else if (QFile::exists(systemFace))
-                    user->icon = QStringLiteral("file://%1").arg(systemFace);
+                    userIcon = accountsServiceFace;
+
+                if (!userIcon.isEmpty())
+                    user->icon = QStringLiteral("file://%1").arg(userIcon);
             }
         }
     }
diff --git a/src/greeter/UserModel.h b/src/greeter/UserModel.h
index b63cf9a..48e04b6 100644
--- a/src/greeter/UserModel.h
+++ b/src/greeter/UserModel.h
@@ -43,6 +43,7 @@ namespace SDDM {
             IconRole,
             NeedsPasswordRole
         };
+        Q_ENUM(UserRoles)
 
         UserModel(bool needAllUsers, QObject *parent = 0);
         ~UserModel();
diff --git a/src/greeter/waylandkeyboardbackend.cpp b/src/greeter/waylandkeyboardbackend.cpp
new file mode 100644
index 0000000..15c580e
--- /dev/null
+++ b/src/greeter/waylandkeyboardbackend.cpp
@@ -0,0 +1,65 @@
+/***************************************************************************
+* Copyright (c) 2021 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#include <QDir>
+
+#include "KeyboardModel.h"
+#include "KeyboardModel_p.h"
+#include "KeyboardLayout.h"
+#include "waylandkeyboardbackend.h"
+
+namespace SDDM {
+
+WaylandKeyboardBackend::WaylandKeyboardBackend(KeyboardModelPrivate *kmp)
+    : KeyboardBackend(kmp)
+{
+}
+
+WaylandKeyboardBackend::~WaylandKeyboardBackend()
+{
+}
+
+void WaylandKeyboardBackend::init()
+{
+    d->layouts.clear();
+
+    QDir dir(QStringLiteral("/usr/share/X11/xkb/symbols"));
+    auto entries = dir.entryList(QDir::Files);
+    for (const auto &entry : qAsConst(entries))
+        d->layouts << new KeyboardLayout(entry, entry);
+}
+
+void WaylandKeyboardBackend::disconnect()
+{
+}
+
+void WaylandKeyboardBackend::sendChanges()
+{
+}
+
+void WaylandKeyboardBackend::dispatchEvents()
+{
+}
+
+void WaylandKeyboardBackend::connectEventsDispatcher(KeyboardModel *model)
+{
+    Q_UNUSED(model);
+}
+
+} // namespace SDDM
diff --git a/src/greeter/waylandkeyboardbackend.h b/src/greeter/waylandkeyboardbackend.h
new file mode 100644
index 0000000..1ab4348
--- /dev/null
+++ b/src/greeter/waylandkeyboardbackend.h
@@ -0,0 +1,43 @@
+/***************************************************************************
+* Copyright (c) 2021 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#ifndef WAYLANDKEYBOARDBACKEND_H
+#define WAYLANDKEYBOARDBACKEND_H
+
+#include "KeyboardBackend.h"
+
+namespace SDDM {
+
+class WaylandKeyboardBackend : public KeyboardBackend
+{
+public:
+    WaylandKeyboardBackend(KeyboardModelPrivate *kmp);
+    virtual ~WaylandKeyboardBackend();
+
+    void init() override;
+    void disconnect() override;
+    void sendChanges() override;
+    void dispatchEvents() override;
+
+    void connectEventsDispatcher(KeyboardModel *model) override;
+};
+
+} // namespace SDDM
+
+#endif // WAYLANDKEYBOARDBACKEND_H
diff --git a/src/helper/Backend.cpp b/src/helper/Backend.cpp
index a324b39..9a36a62 100644
--- a/src/helper/Backend.cpp
+++ b/src/helper/Backend.cpp
@@ -54,6 +54,11 @@ namespace SDDM {
         m_autologin = on;
     }
 
+    void Backend::setDisplayServer(bool on)
+    {
+        m_displayServer = on;
+    }
+
     void Backend::setGreeter(bool on) {
         m_greeter = on;
     }
diff --git a/src/helper/Backend.h b/src/helper/Backend.h
index b790e00..915d09c 100644
--- a/src/helper/Backend.h
+++ b/src/helper/Backend.h
@@ -36,6 +36,7 @@ namespace SDDM {
         static Backend *get(HelperApp *parent);
 
         void setAutologin(bool on = true);
+        void setDisplayServer(bool on = true);
         void setGreeter(bool on = true);
 
     public slots:
@@ -50,6 +51,7 @@ namespace SDDM {
         Backend(HelperApp *parent);
         HelperApp *m_app;
         bool m_autologin { false };
+        bool m_displayServer = false;
         bool m_greeter { false };
     };
 }
diff --git a/src/helper/CMakeLists.txt b/src/helper/CMakeLists.txt
index 8914ea7..bf06c78 100644
--- a/src/helper/CMakeLists.txt
+++ b/src/helper/CMakeLists.txt
@@ -10,6 +10,8 @@ set(HELPER_SOURCES
     ${CMAKE_SOURCE_DIR}/src/common/Configuration.cpp
     ${CMAKE_SOURCE_DIR}/src/common/ConfigReader.cpp
     ${CMAKE_SOURCE_DIR}/src/common/SafeDataStream.cpp
+    ${CMAKE_SOURCE_DIR}/src/common/XAuth.cpp
+    ${CMAKE_SOURCE_DIR}/src/common/SignalHandler.cpp
     Backend.cpp
     HelperApp.cpp
     UserSession.cpp
@@ -60,8 +62,23 @@ else()
     target_link_libraries(sddm-helper crypt)
 endif()
 
+install(TARGETS sddm-helper RUNTIME DESTINATION "${CMAKE_INSTALL_LIBEXECDIR}")
+
+add_executable(sddm-helper-start-wayland HelperStartWayland.cpp waylandsocketwatcher.cpp waylandhelper.cpp ${CMAKE_SOURCE_DIR}/src/common/SignalHandler.cpp)
+target_link_libraries(sddm-helper-start-wayland Qt5::Core)
+install(TARGETS sddm-helper-start-wayland RUNTIME DESTINATION "${CMAKE_INSTALL_LIBEXECDIR}")
+
+add_executable(sddm-helper-start-x11user HelperStartX11User.cpp xorguserhelper.cpp
+                                                ${CMAKE_SOURCE_DIR}/src/common/ConfigReader.cpp
+                                                ${CMAKE_SOURCE_DIR}/src/common/Configuration.cpp
+                                                ${CMAKE_SOURCE_DIR}/src/common/XAuth.cpp
+                                                ${CMAKE_SOURCE_DIR}/src/common/SignalHandler.cpp
+                                                )
+target_link_libraries(sddm-helper-start-x11user Qt5::Core)
+install(TARGETS sddm-helper-start-x11user RUNTIME DESTINATION "${CMAKE_INSTALL_LIBEXECDIR}")
+
 if(JOURNALD_FOUND)
     target_link_libraries(sddm-helper ${JOURNALD_LIBRARIES})
+    target_link_libraries(sddm-helper-start-x11user ${JOURNALD_LIBRARIES})
+    target_link_libraries(sddm-helper-start-wayland ${JOURNALD_LIBRARIES})
 endif()
-
-install(TARGETS sddm-helper RUNTIME DESTINATION "${CMAKE_INSTALL_LIBEXECDIR}")
diff --git a/src/helper/HelperApp.cpp b/src/helper/HelperApp.cpp
index 672359a..ba572a5 100644
--- a/src/helper/HelperApp.cpp
+++ b/src/helper/HelperApp.cpp
@@ -20,11 +20,13 @@
 
 #include "HelperApp.h"
 #include "Backend.h"
+#include "Configuration.h"
 #include "UserSession.h"
 #include "SafeDataStream.h"
 
 #include "MessageHandler.h"
 #include "VirtualTerminal.h"
+#include "SignalHandler.h"
 
 #include <QtCore/QTimer>
 #include <QtCore/QFile>
@@ -41,6 +43,7 @@
 #endif
 #include <utmpx.h>
 #include <QByteArray>
+#include <signal.h>
 
 namespace SDDM {
     HelperApp::HelperApp(int& argc, char** argv)
@@ -49,12 +52,16 @@ namespace SDDM {
             , m_session(new UserSession(this))
             , m_socket(new QLocalSocket(this)) {
         qInstallMessageHandler(HelperMessageHandler);
+        SDDM::SignalHandler s;
+        QObject::connect(&s, &SDDM::SignalHandler::sigtermReceived, QCoreApplication::instance(), [] {
+            QCoreApplication::instance()->exit(-1);
+        });
 
         QTimer::singleShot(0, this, SLOT(setUp()));
     }
 
     void HelperApp::setUp() {
-        QStringList args = QCoreApplication::arguments();
+        const QStringList args = QCoreApplication::arguments();
         QString server;
         int pos;
 
@@ -94,6 +101,16 @@ namespace SDDM {
             m_user = args[pos + 1];
         }
 
+        if ((pos = args.indexOf(QStringLiteral("--display-server"))) >= 0) {
+            if (pos >= args.length() - 1) {
+                qCritical() << "This application is not supposed to be executed manually";
+                exit(Auth::HELPER_OTHER_ERROR);
+                return;
+            }
+            m_session->setDisplayServerCommand(args[pos + 1]);
+            m_backend->setDisplayServer(true);
+        }
+
         if ((pos = args.indexOf(QStringLiteral("--autologin"))) >= 0) {
             m_backend->setAutologin(true);
         }
@@ -109,7 +126,7 @@ namespace SDDM {
         }
 
         connect(m_socket, &QLocalSocket::connected, this, &HelperApp::doAuth);
-        connect(m_session, QOverload<int>::of(&QProcess::finished), this, &HelperApp::sessionFinished);
+        connect(m_session, &UserSession::finished, this, &HelperApp::sessionFinished);
         m_socket->connectToServer(server, QIODevice::ReadWrite | QIODevice::Unbuffered);
     }
 
@@ -124,22 +141,23 @@ namespace SDDM {
             authenticated(QString());
 
             // write failed login to btmp
-            QProcessEnvironment env = m_session->processEnvironment();
-            QString displayId = env.value(QStringLiteral("DISPLAY"));
-            QString vt = env.value(QStringLiteral("XDG_VTNR"));
+            const QProcessEnvironment env = m_session->processEnvironment();
+            const QString displayId = env.value(QStringLiteral("DISPLAY"));
+            const QString vt = env.value(QStringLiteral("XDG_VTNR"));
             utmpLogin(vt, displayId, m_user, 0, false);
 
             exit(Auth::HELPER_AUTH_ERROR);
             return;
         }
 
+        Q_ASSERT(getuid() == 0);
         if (!m_backend->authenticate()) {
             authenticated(QString());
 
             // write failed login to btmp
-            QProcessEnvironment env = m_session->processEnvironment();
-            QString displayId = env.value(QStringLiteral("DISPLAY"));
-            QString vt = env.value(QStringLiteral("XDG_VTNR"));
+            const QProcessEnvironment env = m_session->processEnvironment();
+            const QString displayId = env.value(QStringLiteral("DISPLAY"));
+            const QString vt = env.value(QStringLiteral("XDG_VTNR"));
             utmpLogin(vt, displayId, m_user, 0, false);
 
             exit(Auth::HELPER_AUTH_ERROR);
@@ -149,13 +167,19 @@ namespace SDDM {
         m_user = m_backend->userName();
         QProcessEnvironment env = authenticated(m_user);
 
+        if (env.value(QStringLiteral("XDG_SESSION_CLASS")) == QLatin1String("greeter")) {
+            for (const auto &entry : mainConfig.GreeterEnvironment.get()) {
+                const int index = entry.indexOf(QLatin1Char('='));
+                if (index < 0) {
+                    qWarning() << "Malformed environment variable" << entry;
+                    continue;
+                }
+                env.insert(entry.left(index), entry.mid(index + 1));
+            }
+        }
+
         if (!m_session->path().isEmpty()) {
             env.insert(m_session->processEnvironment());
-            // Allocate a new VT for the wayland session
-            if(env.value(QStringLiteral("XDG_SESSION_TYPE")) == QLatin1String("wayland")) {
-                int vtNumber = VirtualTerminal::setUpNewVt();
-                env.insert(QStringLiteral("XDG_VTNR"), QString::number(vtNumber));
-            }
             m_session->setProcessEnvironment(env);
 
             if (!m_backend->openSession()) {
@@ -167,12 +191,11 @@ namespace SDDM {
             sessionOpened(true);
 
             // write successful login to utmp/wtmp
-            QProcessEnvironment env = m_session->processEnvironment();
-            QString displayId = env.value(QStringLiteral("DISPLAY"));
-            QString vt = env.value(QStringLiteral("XDG_VTNR"));
+            const QProcessEnvironment env = m_session->processEnvironment();
+            const QString displayId = env.value(QStringLiteral("DISPLAY"));
+            const QString vt = env.value(QStringLiteral("XDG_VTNR"));
             if (env.value(QStringLiteral("XDG_SESSION_CLASS")) != QLatin1String("greeter")) {
                 // cache pid for session end
-                m_session->setCachedProcessId(m_session->processId());
                 utmpLogin(vt, displayId, m_user, m_session->processId(), true);
             }
         }
@@ -182,17 +205,6 @@ namespace SDDM {
     }
 
     void HelperApp::sessionFinished(int status) {
-        m_backend->closeSession();
-
-        // write logout to utmp/wtmp
-        qint64 pid = m_session->cachedProcessId();
-        QProcessEnvironment env = m_session->processEnvironment();
-        if (env.value(QStringLiteral("XDG_SESSION_CLASS")) != QLatin1String("greeter")) {
-            QString vt = env.value(QStringLiteral("XDG_VTNR"));
-            QString displayId = env.value(QStringLiteral("DISPLAY"));
-            utmpLogout(vt, displayId, pid);
-        }
-
         exit(status);
     }
 
@@ -255,6 +267,19 @@ namespace SDDM {
         }
     }
 
+    void HelperApp::displayServerStarted(const QString &displayName)
+    {
+        Msg m = Msg::MSG_UNKNOWN;
+        SafeDataStream str(m_socket);
+        str << Msg::DISPLAY_SERVER_STARTED << displayName;
+        str.send();
+        str.receive();
+        str >> m;
+        if (m != DISPLAY_SERVER_STARTED) {
+            qCritical() << "Received a wrong opcode instead of DISPLAY_SERVER_STARTED:" << m;
+        }
+    }
+
     UserSession *HelperApp::session() {
         return m_session;
     }
@@ -268,7 +293,22 @@ namespace SDDM {
     }
 
     HelperApp::~HelperApp() {
+        Q_ASSERT(getuid() == 0);
 
+        m_session->stop();
+        m_backend->closeSession();
+
+        // write logout to utmp/wtmp
+        qint64 pid = m_session->cachedProcessId();
+        if (pid < 0) {
+            return;
+        }
+        QProcessEnvironment env = m_session->processEnvironment();
+        if (env.value(QStringLiteral("XDG_SESSION_CLASS")) != QLatin1String("greeter")) {
+            QString vt = env.value(QStringLiteral("XDG_VTNR"));
+            QString displayId = env.value(QStringLiteral("DISPLAY"));
+            utmpLogout(vt, displayId, pid);
+        }
     }
 
     void HelperApp::utmpLogin(const QString &vt, const QString &displayName, const QString &user, qint64 pid, bool authSuccessful) {
diff --git a/src/helper/HelperApp.h b/src/helper/HelperApp.h
index 3742df1..0e8c02a 100644
--- a/src/helper/HelperApp.h
+++ b/src/helper/HelperApp.h
@@ -47,6 +47,7 @@ namespace SDDM {
         void info(const QString &message, Auth::Info type);
         void error(const QString &message, Auth::Error type);
         QProcessEnvironment authenticated(const QString &user);
+        void displayServerStarted(const QString &displayName);
         void sessionOpened(bool success);
 
     private slots:
diff --git a/src/helper/HelperStartWayland.cpp b/src/helper/HelperStartWayland.cpp
new file mode 100644
index 0000000..8c33aca
--- /dev/null
+++ b/src/helper/HelperStartWayland.cpp
@@ -0,0 +1,67 @@
+/*
+ * Session process wrapper
+ * Copyright (C) 2021 Aleix Pol Gonzalez <aleixpol@kde.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+/**
+ * This application sole purpose is to launch a wayland compositor (first
+ * argument) and as soon as it's set up to launch a client (second argument)
+ */
+
+#include <unistd.h>
+#include <QCoreApplication>
+#include <QTextStream>
+#include "waylandhelper.h"
+#include "MessageHandler.h"
+#include <signal.h>
+#include "SignalHandler.h"
+
+void WaylandHelperMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg) {
+    SDDM::messageHandler(type, context, QStringLiteral("WaylandHelper: "), msg);
+}
+
+int main(int argc, char** argv)
+{
+    qInstallMessageHandler(WaylandHelperMessageHandler);
+    SDDM::SignalHandler s;
+    QObject::connect(&s, &SDDM::SignalHandler::sigtermReceived, QCoreApplication::instance(), [] {
+        QCoreApplication::instance()->exit(-1);
+    });
+
+    Q_ASSERT(::getuid() != 0);
+    QCoreApplication app(argc, argv);
+    if (argc != 3) {
+        QTextStream(stderr) << "Wrong number of arguments\n";
+        return 1;
+    }
+
+    using namespace SDDM;
+    WaylandHelper helper;
+    QObject::connect(&app, &QCoreApplication::aboutToQuit, &helper, [&helper] {
+        qDebug("quitting helper-start-wayland");
+        helper.stop();
+    });
+    QObject::connect(&helper, &WaylandHelper::failed, &app, [&app] {
+        QTextStream(stderr) << "Failed to start wayland session" << Qt::endl;
+        app.exit(2);
+    });
+
+    helper.startCompositor(app.arguments()[1]);
+    helper.startGreeter(app.arguments()[2]);
+    return app.exec();
+}
diff --git a/src/helper/HelperStartX11User.cpp b/src/helper/HelperStartX11User.cpp
new file mode 100644
index 0000000..2eed786
--- /dev/null
+++ b/src/helper/HelperStartX11User.cpp
@@ -0,0 +1,76 @@
+/*
+ * Session process wrapper
+ * Copyright (C) 2021 Aleix Pol Gonzalez <aleixpol@kde.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+/**
+ * This application sole purpose is to launch an X11 rootless compositor compositor (first
+ * argument) and as soon as it's set up to launch a client (second argument)
+ */
+
+#include <unistd.h>
+#include <QCoreApplication>
+#include <QTextStream>
+#include <QProcess>
+#include <QDebug>
+#include "xorguserhelper.h"
+#include "MessageHandler.h"
+#include <signal.h>
+#include "SignalHandler.h"
+
+void X11UserHelperMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg) {
+    SDDM::messageHandler(type, context, QStringLiteral("X11UserHelper: "), msg);
+}
+
+int main(int argc, char** argv)
+{
+    qInstallMessageHandler(X11UserHelperMessageHandler);
+    SDDM::SignalHandler s;
+    QObject::connect(&s, &SDDM::SignalHandler::sigtermReceived, QCoreApplication::instance(), [] {
+        QCoreApplication::instance()->exit(-1);
+    });
+
+    Q_ASSERT(::getuid() != 0);
+    QCoreApplication app(argc, argv);
+    if (argc != 3) {
+        QTextStream(stderr) << "Wrong number of arguments\n";
+        return 33;
+    }
+
+    using namespace SDDM;
+    XOrgUserHelper helper;
+    QObject::connect(&app, &QCoreApplication::aboutToQuit, &helper, [&helper] {
+        qDebug("quitting helper-start-wayland");
+        helper.stop();
+    });
+    QObject::connect(&helper, &XOrgUserHelper::displayChanged, &app, [&helper, &app] {
+        qDebug() << "starting XOrg Greeter..." << helper.sessionEnvironment().value(QStringLiteral("DISPLAY"));
+        auto args = QProcess::splitCommand(app.arguments()[2]);
+
+        QProcess *process = new QProcess(&app);
+        process->setProcessChannelMode(QProcess::ForwardedChannels);
+        process->setProgram(args.takeFirst());
+        process->setArguments(args);
+        process->setProcessEnvironment(helper.sessionEnvironment());
+        process->start();
+        QObject::connect(process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished), &app, &QCoreApplication::quit);
+    });
+
+    helper.start(app.arguments()[1]);
+    return app.exec();
+}
diff --git a/src/helper/UserSession.cpp b/src/helper/UserSession.cpp
index c9a8a20..4a52bea 100644
--- a/src/helper/UserSession.cpp
+++ b/src/helper/UserSession.cpp
@@ -19,10 +19,13 @@
  *
  */
 
+#include <QSocketNotifier>
+
 #include "Configuration.h"
 #include "UserSession.h"
 #include "HelperApp.h"
 #include "VirtualTerminal.h"
+#include "XAuth.h"
 
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -34,34 +37,92 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <sched.h>
+#ifdef Q_OS_FREEBSD
+#include <login_cap.h>
+#endif
 
 namespace SDDM {
     UserSession::UserSession(HelperApp *parent)
-            : QProcess(parent) {
+        : QProcess(parent)
+    {
+        connect(this, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished), this, &UserSession::finished);
     }
 
-    UserSession::~UserSession() {
+    bool UserSession::start() {
+        auto helper = qobject_cast<HelperApp*>(parent());
+        QProcessEnvironment env = helper->session()->processEnvironment();
+
+        bool isWaylandGreeter = false;
+        if (env.value(QStringLiteral("XDG_SESSION_TYPE")) == QLatin1String("x11")) {
+            QString command;
+            if (env.value(QStringLiteral("XDG_SESSION_CLASS")) == QLatin1String("greeter")) {
+                command = m_path;
+            } else {
+                command = QStringLiteral("%1 \"%2\"").arg(mainConfig.X11.SessionCommand.get()).arg(m_path);
+            }
 
-    }
+            qInfo() << "Starting X11 session:" << m_displayServerCmd << command;
+            if (m_displayServerCmd.isEmpty()) {
+                auto args = QProcess::splitCommand(command);
+                const auto program = args.takeFirst();
+                QProcess::start(program, args);
+            } else {
+                QProcess::start(QStringLiteral(LIBEXEC_INSTALL_DIR "/sddm-helper-start-x11user"), {m_displayServerCmd, command});
+            }
 
-    bool UserSession::start() {
-        QProcessEnvironment env = qobject_cast<HelperApp*>(parent())->session()->processEnvironment();
-
-        if (env.value(QStringLiteral("XDG_SESSION_CLASS")) == QLatin1String("greeter")) {
-            QProcess::start(m_path);
-        } else if (env.value(QStringLiteral("XDG_SESSION_TYPE")) == QLatin1String("x11")) {
-            const QString cmd = QStringLiteral("%1 \"%2\"").arg(mainConfig.X11.SessionCommand.get()).arg(m_path);
-            qInfo() << "Starting:" << cmd;
-            QProcess::start(cmd);
         } else if (env.value(QStringLiteral("XDG_SESSION_TYPE")) == QLatin1String("wayland")) {
-            const QString cmd = QStringLiteral("%1 %2").arg(mainConfig.Wayland.SessionCommand.get()).arg(m_path);
-            qInfo() << "Starting:" << cmd;
-            QProcess::start(cmd);
+            if (env.value(QStringLiteral("XDG_SESSION_CLASS")) == QLatin1String("greeter")) {
+                Q_ASSERT(!m_displayServerCmd.isEmpty());
+                QProcess::start(QStringLiteral(LIBEXEC_INSTALL_DIR "/sddm-helper-start-wayland"), {m_displayServerCmd, m_path});
+                isWaylandGreeter = true;
+            } else {
+                const QString cmd = QStringLiteral("%1 %2").arg(mainConfig.Wayland.SessionCommand.get()).arg(m_path);
+                qInfo() << "Starting Wayland user session:" << cmd;
+                QProcess::start(mainConfig.Wayland.SessionCommand.get(), QStringList{m_path});
+                closeWriteChannel();
+                closeReadChannel(QProcess::StandardOutput);
+            }
         } else {
             qCritical() << "Unable to run user session: unknown session type";
         }
 
-        return waitForStarted();
+        const bool started = waitForStarted();
+        m_cachedProcessId = processId();
+        if (started) {
+            return true;
+        } else if (isWaylandGreeter) {
+            // This is probably fine, we need the compositor to start first
+            return true;
+        }
+
+        return false;
+    }
+
+    void UserSession::stop()
+    {
+        if (state() != QProcess::NotRunning) {
+            terminate();
+            const bool isGreeter = processEnvironment().value(QStringLiteral("XDG_SESSION_CLASS")) == QLatin1String("greeter");
+
+            // Wait longer for a session than a greeter
+            if (!waitForFinished(isGreeter ? 5000 : 60000)) {
+                kill();
+                if (!waitForFinished(5000)) {
+                    qWarning() << "Could not fully finish the process" << program();
+                }
+            }
+        }
+        Q_EMIT finished(Auth::HELPER_OTHER_ERROR);
+    }
+
+    QString UserSession::displayServerCommand() const
+    {
+        return m_displayServerCmd;
+    }
+
+    void UserSession::setDisplayServerCommand(const QString &command)
+    {
+        m_displayServerCmd = command;
     }
 
     void UserSession::setPath(const QString& path) {
@@ -75,10 +136,14 @@ namespace SDDM {
     void UserSession::setupChildProcess() {
         // Session type
         QString sessionType = processEnvironment().value(QStringLiteral("XDG_SESSION_TYPE"));
-
-        // For Wayland sessions we leak the VT into the session as stdin so
-        // that it stays open without races
-        if (sessionType == QLatin1String("wayland")) {
+        QString sessionClass = processEnvironment().value(QStringLiteral("XDG_SESSION_CLASS"));
+        const bool hasDisplayServer = !m_displayServerCmd.isEmpty();
+        const bool x11UserSession = sessionType == QLatin1String("x11") && sessionClass == QLatin1String("user");
+        const bool waylandUserSession = sessionType == QLatin1String("wayland") && sessionClass == QLatin1String("user");
+
+        // When the display server is part of the session, we leak the VT into
+        // the session as stdin so that it stays open without races
+        if (hasDisplayServer || waylandUserSession) {
             // open VT and get the fd
             int vtNumber = processEnvironment().value(QStringLiteral("XDG_VTNR")).toInt();
             QString ttyString = QStringLiteral("/dev/tty%1").arg(vtNumber);
@@ -107,12 +172,13 @@ namespace SDDM {
             // take control of the tty
             if (takeControl) {
                 if (ioctl(STDIN_FILENO, TIOCSCTTY) < 0) {
-                    qCritical("Failed to take control of the tty: %s", strerror(errno));
+                    const auto error = strerror(errno);
+                    qCritical().nospace() << "Failed to take control of " << ttyString << " (" << QFileInfo(ttyString).owner() << "): " << error;
                     exit(Auth::HELPER_OTHER_ERROR);
                 }
             }
 
-            VirtualTerminal::jumpToVt(vtNumber, false);
+            VirtualTerminal::jumpToVt(vtNumber, x11UserSession);
         }
 
 #ifdef Q_OS_LINUX
@@ -150,10 +216,19 @@ namespace SDDM {
                 qCritical() << "getpwnam_r(" << username << ") failed with error: " << strerror(err);
             exit(Auth::HELPER_OTHER_ERROR);
         }
+#if defined(Q_OS_FREEBSD)
+        // execve() uses the environment prepared in Backend::openSession(),
+        // therefore environment variables which are set here are ignored.
+        if (setusercontext(NULL, &pw, pw.pw_uid, LOGIN_SETALL) != 0) {
+            qCritical() << "setusercontext(NULL, *, " << pw.pw_uid << ", LOGIN_SETALL) failed for user: " << username;
+            exit(Auth::HELPER_OTHER_ERROR);
+        }
+#else
         if (setgid(pw.pw_gid) != 0) {
             qCritical() << "setgid(" << pw.pw_gid << ") failed for user: " << username;
             exit(Auth::HELPER_OTHER_ERROR);
         }
+        qputenv("XDG_RUNTIME_DIR", QByteArrayLiteral("/run/user/") + QByteArray::number(pw.pw_uid));
 
 #ifdef USE_PAM
 
@@ -175,13 +250,13 @@ namespace SDDM {
         // fetch session's user's groups
         int n_user_groups = 0;
         gid_t *user_groups = NULL;
-        if (-1 == getgrouplist(username.constData(), pw.pw_gid,
+        if (-1 == getgrouplist(pw.pw_name, pw.pw_gid,
                                NULL, &n_user_groups)) {
             user_groups = new gid_t[n_user_groups];
-            if ((n_user_groups = getgrouplist(username.constData(),
+            if ((n_user_groups = getgrouplist(pw.pw_name,
                                               pw.pw_gid, user_groups,
                                               &n_user_groups)) == -1 ) {
-                qCritical() << "getgrouplist(" << username << ", " << pw.pw_gid
+                qCritical() << "getgrouplist(" << pw.pw_name << ", " << pw.pw_gid
                             << ") failed";
                 exit(Auth::HELPER_OTHER_ERROR);
             }
@@ -219,86 +294,50 @@ namespace SDDM {
             qCritical() << "setuid(" << pw.pw_uid << ") failed for user: " << username;
             exit(Auth::HELPER_OTHER_ERROR);
         }
+#endif /* Q_OS_FREEBSD */
         if (chdir(pw.pw_dir) != 0) {
             qCritical() << "chdir(" << pw.pw_dir << ") failed for user: " << username;
             qCritical() << "verify directory exist and has sufficient permissions";
             exit(Auth::HELPER_OTHER_ERROR);
         }
-        const QString homeDir = QString::fromLocal8Bit(pw.pw_dir);
-
-        //we cannot use setStandardError file as this code is run in the child process
-        //we want to redirect after we setuid so that the log file is owned by the user
-
-        // determine stderr log file based on session type
-        QString sessionLog = QStringLiteral("%1/%2")
-                .arg(homeDir)
-                .arg(sessionType == QLatin1String("x11")
-                     ? mainConfig.X11.SessionLogFile.get()
-                     : mainConfig.Wayland.SessionLogFile.get());
-
-        // create the path
-        QFileInfo finfo(sessionLog);
-        QDir().mkpath(finfo.absolutePath());
-
-        //swap the stderr pipe of this subprcess into a file
-        int fd = ::open(qPrintable(sessionLog), O_WRONLY | O_CREAT | O_TRUNC, 0600);
-        if (fd >= 0)
-        {
-            dup2 (fd, STDERR_FILENO);
-            ::close(fd);
-        } else {
-            qWarning() << "Could not open stderr to" << sessionLog;
-        }
-
-        //redirect any stdout to /dev/null
-        fd = ::open("/dev/null", O_WRONLY);
-        if (fd >= 0)
-        {
-            dup2 (fd, STDOUT_FILENO);
-            ::close(fd);
-        } else {
-            qWarning() << "Could not redirect stdout";
-        }
 
-        // set X authority for X11 sessions only
-        if (sessionType != QLatin1String("x11"))
-            return;
-        QString cookie = qobject_cast<HelperApp*>(parent())->cookie();
-        if (!cookie.isEmpty()) {
-            QString file = processEnvironment().value(QStringLiteral("XAUTHORITY"));
-            QString display = processEnvironment().value(QStringLiteral("DISPLAY"));
-            qDebug() << "Adding cookie to" << file;
+        if (sessionClass != QLatin1String("greeter")) {
+            //we cannot use setStandardError file as this code is run in the child process
+            //we want to redirect after we setuid so that the log file is owned by the user
 
+            // determine stderr log file based on session type
+            QString sessionLog = QStringLiteral("%1/%2")
+                    .arg(QString::fromLocal8Bit(pw.pw_dir))
+                    .arg(sessionType == QLatin1String("x11")
+                         ? mainConfig.X11.SessionLogFile.get()
+                         : mainConfig.Wayland.SessionLogFile.get());
 
             // create the path
-            QFileInfo finfo(file);
+            QFileInfo finfo(sessionLog);
             QDir().mkpath(finfo.absolutePath());
 
-            QFile file_handler(file);
-            file_handler.open(QIODevice::Append);
-            file_handler.close();
-
-            QString cmd = QStringLiteral("%1 -f %2 -q").arg(mainConfig.X11.XauthPath.get()).arg(file);
+            setStandardErrorFile(sessionLog);
+            setStandardOutputFile(QProcess::nullDevice());
+        } else {
+            setProcessChannelMode(QProcess::ForwardedChannels);
+        }
 
-            // execute xauth
-            FILE *fp = popen(qPrintable(cmd), "w");
+        // set X authority for X11 sessions only
+        if (x11UserSession) {
+            QString cookie = qobject_cast<HelperApp*>(parent())->cookie();
+            if (!cookie.isEmpty()) {
+                QString file = processEnvironment().value(QStringLiteral("XAUTHORITY"));
+                QString display = processEnvironment().value(QStringLiteral("DISPLAY"));
 
-            // check file
-            if (!fp)
-                return;
-            fprintf(fp, "remove %s\n", qPrintable(display));
-            fprintf(fp, "add %s . %s\n", qPrintable(display), qPrintable(cookie));
-            fprintf(fp, "exit\n");
+                // Create the path
+                QFileInfo finfo(file);
+                QDir().mkpath(finfo.absolutePath());
 
-            // close pipe
-            pclose(fp);
+                XAuth::addCookieToFile(display, file, cookie);
+            }
         }
     }
 
-    void UserSession::setCachedProcessId(qint64 pid) {
-        m_cachedProcessId = pid;
-    }
-
     qint64 UserSession::cachedProcessId() {
         return m_cachedProcessId;
     }
diff --git a/src/helper/UserSession.h b/src/helper/UserSession.h
index 7069084..bcc286b 100644
--- a/src/helper/UserSession.h
+++ b/src/helper/UserSession.h
@@ -23,42 +23,51 @@
 #define SDDM_AUTH_SESSION_H
 
 #include <QtCore/QObject>
-#include <QtCore/QString>
 #include <QtCore/QProcess>
 
 namespace SDDM {
     class HelperApp;
+    class XOrgUserHelper;
+    class WaylandHelper;
     class UserSession : public QProcess
     {
         Q_OBJECT
     public:
         explicit UserSession(HelperApp *parent);
-        virtual ~UserSession();
 
         bool start();
+        void stop();
+
+        QString displayServerCommand() const;
+        void setDisplayServerCommand(const QString &command);
 
         void setPath(const QString &path);
         QString path() const;
 
-        /*!
-         \brief Sets m_cachedProcessId. Needed for getting the PID of a finished UserSession
-                and calling HelperApp::utmpLogout
-         \param pid  The process ID
-        */
-        void setCachedProcessId(qint64 pid);
-
         /*!
          \brief Gets m_cachedProcessId
          \return  The cached process ID
         */
         qint64 cachedProcessId();
 
+
+    Q_SIGNALS:
+        void finished(int exitCode);
+
+
     protected:
-        void setupChildProcess();
+        void setupChildProcess() override;
 
     private:
+        void setup();
+
         QString m_path { };
-        qint64 m_cachedProcessId;
+        QString m_displayServerCmd;
+
+        /*!
+         Needed for getting the PID of a finished UserSession and calling HelperApp::utmpLogout
+        */
+        qint64 m_cachedProcessId = -1;
     };
 }
 
diff --git a/src/helper/backend/PamBackend.cpp b/src/helper/backend/PamBackend.cpp
index f86d77d..c97056a 100644
--- a/src/helper/backend/PamBackend.cpp
+++ b/src/helper/backend/PamBackend.cpp
@@ -248,7 +248,9 @@ namespace SDDM {
         }
 
         QProcessEnvironment sessionEnv = m_app->session()->processEnvironment();
-        if (sessionEnv.value(QStringLiteral("XDG_SESSION_TYPE")) == QLatin1String("x11")) {
+        const auto sessionType = sessionEnv.value(QStringLiteral("XDG_SESSION_TYPE"));
+        const auto sessionClass = sessionEnv.value(QStringLiteral("XDG_SESSION_CLASS"));
+        if (sessionType == QLatin1String("x11") && (sessionClass == QLatin1String("user") || !m_displayServer)) {
             QString display = sessionEnv.value(QStringLiteral("DISPLAY"));
             if (!display.isEmpty()) {
 #ifdef PAM_XDISPLAY
@@ -256,7 +258,7 @@ namespace SDDM {
 #endif
                 m_pam->setItem(PAM_TTY, qPrintable(display));
             }
-        } else if (sessionEnv.value(QStringLiteral("XDG_SESSION_TYPE")) == QLatin1String("wayland")) {
+        } else {
             QString tty = QStringLiteral("/dev/tty%1").arg(sessionEnv.value(QStringLiteral("XDG_VTNR")));
             m_pam->setItem(PAM_TTY, qPrintable(tty));
         }
diff --git a/src/helper/waylandhelper.cpp b/src/helper/waylandhelper.cpp
new file mode 100644
index 0000000..2098065
--- /dev/null
+++ b/src/helper/waylandhelper.cpp
@@ -0,0 +1,139 @@
+/***************************************************************************
+* Copyright (c) 2021 Aleix Pol Gonzalez <aleixpol@kde.org>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#include <QCoreApplication>
+#include <QFile>
+#include <QStandardPaths>
+
+#include "Configuration.h"
+
+#include "waylandhelper.h"
+#include "waylandsocketwatcher.h"
+#include "VirtualTerminal.h"
+
+#include <fcntl.h>
+#include <unistd.h>
+
+namespace SDDM {
+
+WaylandHelper::WaylandHelper(QObject *parent)
+    : QObject(parent)
+    , m_environment(QProcessEnvironment::systemEnvironment())
+    , m_watcher(new WaylandSocketWatcher(this))
+{
+}
+
+QProcessEnvironment WaylandHelper::environment() const
+{
+    return m_environment;
+}
+
+void WaylandHelper::setEnvironment(const QProcessEnvironment &env)
+{
+    m_environment = env;
+}
+
+bool WaylandHelper::startCompositor(const QString &cmd)
+{
+    m_watcher->start();
+    return startProcess(cmd, &m_serverProcess);
+}
+
+void WaylandHelper::stop()
+{
+    m_watcher->stop();
+    if (m_serverProcess) {
+        qInfo("Stopping server...");
+        m_serverProcess->terminate();
+        if (!m_serverProcess->waitForFinished(5000))
+            m_serverProcess->kill();
+        m_serverProcess->deleteLater();
+        m_serverProcess = nullptr;
+    }
+}
+
+bool WaylandHelper::startProcess(const QString &cmd, QProcess **p)
+{
+    auto *process = new QProcess(this);
+    process->setProcessEnvironment(m_environment);
+    process->setInputChannelMode(QProcess::ForwardedInputChannel);
+    connect(process, &QProcess::readyReadStandardError, this, [process] {
+        qWarning() << process->readAllStandardError();
+    });
+    connect(process, &QProcess::readyReadStandardOutput, this, [process] {
+        qInfo() << process->readAllStandardOutput();
+    });
+    qDebug() << "Starting Wayland process" << cmd << m_environment.value(QStringLiteral("USER"));
+    connect(process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
+            process, [](int exitCode, QProcess::ExitStatus exitStatus) {
+        qDebug() << "wayland compositor finished" << exitCode << exitStatus;
+        if (exitCode != 0 || exitStatus != QProcess::NormalExit)
+            QCoreApplication::instance()->quit();
+    });
+
+    auto args = QProcess::splitCommand(cmd);
+    const auto program = args.takeFirst();
+    process->start(program, args);
+    if (!process->waitForStarted(10000)) {
+        qWarning("Failed to start \"%s\": %s",
+                 qPrintable(cmd),
+                 qPrintable(process->errorString()));
+        return false;
+    }
+
+    if (p)
+        *p = process;
+
+    qDebug() << "started succesfully" << cmd;
+    return true;
+}
+
+void WaylandHelper::startGreeter(const QString &cmd)
+{
+    auto args = QProcess::splitCommand(cmd);
+
+    QProcess *process = new QProcess(this);
+    process->setProgram(args.takeFirst());
+    process->setArguments(args);
+    process->setProcessEnvironment(m_environment);
+    connect(process, &QProcess::readyReadStandardError, this, [process] {
+        qWarning() << process->readAllStandardError();
+    });
+    connect(process, &QProcess::readyReadStandardOutput, this, [process] {
+        qInfo() << process->readAllStandardOutput();
+    });
+    startGreeter(process);
+}
+
+void WaylandHelper::startGreeter(QProcess *process)
+{
+    if (m_watcher->status() == WaylandSocketWatcher::Started) {
+        process->start();
+    } else if (m_watcher->status() == WaylandSocketWatcher::Failed) {
+        Q_EMIT failed();
+    } else {
+        connect(m_watcher, &WaylandSocketWatcher::failed, this, &WaylandHelper::failed);
+        connect(m_watcher, &WaylandSocketWatcher::started, this, [this, process] {
+            m_watcher->stop();
+            process->start();
+        });
+    }
+}
+
+} // namespace SDDM
diff --git a/src/helper/waylandhelper.h b/src/helper/waylandhelper.h
new file mode 100644
index 0000000..f1adc74
--- /dev/null
+++ b/src/helper/waylandhelper.h
@@ -0,0 +1,58 @@
+/***************************************************************************
+* Copyright (c) 2021 Aleix Pol Gonzalez <aleixpol@kde.org>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#ifndef WAYLANDHELPER_H
+#define WAYLANDHELPER_H
+
+#include <QProcess>
+
+namespace SDDM {
+class WaylandSocketWatcher;
+
+class WaylandHelper : public QObject
+{
+    Q_OBJECT
+public:
+    explicit WaylandHelper(QObject *parent = nullptr);
+
+    QProcessEnvironment environment() const;
+    void setEnvironment(const QProcessEnvironment &env);
+
+    bool startCompositor(const QString &cmd);
+    void startGreeter(const QString &cmd);
+    void stop();
+
+Q_SIGNALS:
+    void failed();
+
+private:
+    void startGreeter(QProcess *process);
+
+    QProcessEnvironment m_environment;
+    QProcess *m_serverProcess = nullptr;
+    WaylandSocketWatcher * const m_watcher;
+
+    bool startProcess(const QString &cmd, QProcess **p = nullptr);
+};
+
+} // namespace SDDM
+
+
+
+#endif
diff --git a/src/helper/waylandsocketwatcher.cpp b/src/helper/waylandsocketwatcher.cpp
new file mode 100644
index 0000000..3166909
--- /dev/null
+++ b/src/helper/waylandsocketwatcher.cpp
@@ -0,0 +1,100 @@
+/***************************************************************************
+* Copyright (c) 2021 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+* Copyright (C) 2021 Aleix Pol Gonzalez <aleixpol@kde.org>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#include <QDebug>
+#include <QStandardPaths>
+
+#include "waylandsocketwatcher.h"
+
+namespace SDDM {
+
+WaylandSocketWatcher::WaylandSocketWatcher(QObject *parent )
+    : QObject(parent)
+    , m_runtimeDir(QDir(QStandardPaths::writableLocation(QStandardPaths::RuntimeLocation)))
+    , m_socketPath(m_runtimeDir.absoluteFilePath(QLatin1String("wayland-0")))
+{
+}
+
+WaylandSocketWatcher::Status WaylandSocketWatcher::status() const
+{
+    return m_status;
+}
+
+QString WaylandSocketWatcher::socketPath() const
+{
+    return m_socketPath;
+}
+
+void WaylandSocketWatcher::start()
+{
+    m_watcher = new QFileSystemWatcher(this);
+
+    // Give the compositor some time to start
+    m_timer.setSingleShot(true);
+    m_timer.setInterval(15000);
+    connect(&m_timer, &QTimer::timeout, this, [this] {
+        // Time is up and a socket was not found
+        if (!m_watcher.isNull())
+            m_watcher->deleteLater();
+        qWarning("Wayland socket watcher for \"%s\" timed out",
+                 qPrintable(m_socketPath));
+        m_status = Failed;
+        Q_EMIT failed();
+    });
+
+    // Check if the socket exists
+    connect(m_watcher, &QFileSystemWatcher::directoryChanged, this,
+            [this](const QString &path) {
+        qDebug() << "Directory" << path << "has changed, checking for" << m_socketPath;
+
+        if (QFile::exists(m_socketPath)) {
+            m_timer.stop();
+            if (!m_watcher.isNull())
+                m_watcher->deleteLater();
+            m_status = Started;
+            Q_EMIT started();
+        }
+    });
+
+    // Watch for runtime directory changes
+    if (!m_runtimeDir.exists() || !m_watcher->addPath(m_runtimeDir.absolutePath())) {
+        qWarning("Cannot watch directory \"%s\" for Wayland socket \"%s\"",
+                 qPrintable(m_runtimeDir.absolutePath()),
+                 qPrintable(m_socketPath));
+        m_watcher->deleteLater();
+        m_status = Failed;
+        Q_EMIT failed();
+    }
+
+    // Start
+    m_timer.start();
+}
+
+void WaylandSocketWatcher::stop()
+{
+    m_timer.stop();
+    if (!m_watcher.isNull())
+        m_watcher->deleteLater();
+    m_watcher.clear();
+    m_status = Stopped;
+    Q_EMIT stopped();
+}
+
+} // namespace SDDM
diff --git a/src/helper/waylandsocketwatcher.h b/src/helper/waylandsocketwatcher.h
new file mode 100644
index 0000000..dfc5d21
--- /dev/null
+++ b/src/helper/waylandsocketwatcher.h
@@ -0,0 +1,64 @@
+/***************************************************************************
+* Copyright (c) 2021 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#ifndef WAYLANDSOCKETWATCHER_H
+#define WAYLANDSOCKETWATCHER_H
+
+#include <QDir>
+#include <QFileSystemWatcher>
+#include <QPointer>
+#include <QTimer>
+
+namespace SDDM {
+
+class WaylandSocketWatcher : public QObject
+{
+    Q_OBJECT
+public:
+    enum Status {
+        Started,
+        Stopped,
+        Failed
+    };
+    Q_ENUM(Status)
+
+    explicit WaylandSocketWatcher(QObject *parent = nullptr);
+
+    Status status() const;
+    QString socketPath() const;
+
+    void start();
+    void stop();
+
+Q_SIGNALS:
+    void started();
+    void stopped();
+    void failed();
+
+private:
+    Status m_status = Stopped;
+    QDir m_runtimeDir;
+    QString m_socketPath;
+    QTimer m_timer;
+    QPointer<QFileSystemWatcher> m_watcher;
+};
+
+} // namespace SDDM
+
+#endif // WAYLANDSOCKETWATCHER_H
diff --git a/src/helper/xorguserhelper.cpp b/src/helper/xorguserhelper.cpp
new file mode 100644
index 0000000..8d083a8
--- /dev/null
+++ b/src/helper/xorguserhelper.cpp
@@ -0,0 +1,258 @@
+/***************************************************************************
+* Copyright (c) 2021 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#include <QCoreApplication>
+#include <QFile>
+#include <QStandardPaths>
+
+#include "Configuration.h"
+
+#include "xorguserhelper.h"
+
+#include <fcntl.h>
+#include <unistd.h>
+
+namespace SDDM {
+
+XOrgUserHelper::XOrgUserHelper(QObject *parent)
+    : QObject(parent)
+    , m_environment(QProcessEnvironment::systemEnvironment())
+{
+}
+
+QProcessEnvironment XOrgUserHelper::sessionEnvironment() const
+{
+    auto env = m_environment;
+    env.insert(QStringLiteral("DISPLAY"), m_display);
+    env.insert(QStringLiteral("XAUTHORITY"), m_xauth.authPath());
+    env.insert(QStringLiteral("QT_QPA_PLATFORM"), QStringLiteral("xcb"));
+    return env;
+}
+
+QProcessEnvironment XOrgUserHelper::environment() const
+{
+    return m_environment;
+}
+
+void XOrgUserHelper::setEnvironment(const QProcessEnvironment &env)
+{
+    m_environment = env;
+}
+
+QString XOrgUserHelper::display() const
+{
+    return m_display;
+}
+
+QString XOrgUserHelper::xauthPath() const
+{
+    return m_xauth.authPath();
+}
+
+bool XOrgUserHelper::start(const QString &cmd)
+{
+    // Create xauthority
+    m_xauth.setAuthDirectory(m_environment.value(QStringLiteral("XDG_RUNTIME_DIR")));
+    m_xauth.setup();
+
+    // Start server process
+    if (!startServer(cmd))
+        return false;
+
+    // Setup display
+    startDisplayCommand();
+
+    return true;
+}
+
+void XOrgUserHelper::stop()
+{
+    if (m_serverProcess) {
+        qInfo("Stopping server...");
+        m_serverProcess->terminate();
+        if (!m_serverProcess->waitForFinished(5000))
+            m_serverProcess->kill();
+        m_serverProcess->deleteLater();
+        m_serverProcess = nullptr;
+
+        displayFinished();
+    }
+}
+
+bool XOrgUserHelper::startProcess(const QString &cmd,
+                                  const QProcessEnvironment &env,
+                                  QProcess **p)
+{
+    auto args = QProcess::splitCommand(cmd);
+    const auto program = args.takeFirst();
+
+    // Make sure to forward the input of this process into the Xorg
+    // server, otherwise it will complain that only console users are allowed
+    auto *process = new QProcess(this);
+    process->setProcessEnvironment(env);
+    process->setInputChannelMode(QProcess::ForwardedInputChannel);
+    connect(process, &QProcess::readyReadStandardError, this, [process] {
+        qWarning() << process->readAllStandardError();
+    });
+    connect(process, &QProcess::readyReadStandardOutput, this, [process] {
+        qInfo() << process->readAllStandardOutput();
+    });
+    connect(process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
+            process, [](int exitCode, QProcess::ExitStatus exitStatus) {
+        if (exitCode != 0 || exitStatus != QProcess::NormalExit)
+            QCoreApplication::instance()->quit();
+    });
+
+    process->start(program, args);
+    if (!process->waitForStarted(10000)) {
+        qWarning("Failed to start \"%s\": %s",
+                 qPrintable(cmd),
+                 qPrintable(process->errorString()));
+        return false;
+    }
+
+    if (p)
+        *p = process;
+
+    return true;
+}
+
+bool XOrgUserHelper::startServer(const QString &cmd)
+{
+    QString serverCmd = cmd;
+
+    // Create pipe for communicating with X server
+    // 0 == read from X, 1 == write to X
+    int pipeFds[2];
+    if (::pipe(pipeFds) != 0) {
+        qCritical("Could not create pipe to start X server");
+        return false;
+    }
+
+    // Do not leak the read endpoint to the X server process
+    fcntl(pipeFds[0], F_SETFD, FD_CLOEXEC);
+
+    // Server environment
+    // Not setting XORG_RUN_AS_USER_OK=1 will make Xorg require root privileges
+    // under Fedora and all distros that use their patch.
+    // https://src.fedoraproject.org/rpms/xorg-x11-server/blob/rawhide/f/0001-Fedora-hack-Make-the-suid-root-wrapper-always-start-.patch
+    // https://fedoraproject.org/wiki/Changes/XorgWithoutRootRights
+    QProcessEnvironment serverEnv = m_environment;
+    serverEnv.insert(QStringLiteral("XORG_RUN_AS_USER_OK"), QStringLiteral("1"));
+
+    // Append xauth and display fd to the command
+    auto args = QStringList()
+            << QStringLiteral("-auth") << m_xauth.authPath()
+            << QStringLiteral("-displayfd") << QString::number(pipeFds[1]);
+
+    // Append VT from environment
+    args << QStringLiteral("vt%1").arg(serverEnv.value(QStringLiteral("XDG_VTNR")));
+
+    // Command string
+    serverCmd += QLatin1Char(' ') + args.join(QLatin1Char(' '));
+
+    // Start the server process
+    qInfo("Running server: %s", qPrintable(serverCmd));
+    if (!startProcess(serverCmd, serverEnv, &m_serverProcess)) {
+        ::close(pipeFds[0]);
+        return false;
+    }
+
+    // Close the other side of pipe in our process, otherwise reading
+    // from it may stuck even X server exit
+    ::close(pipeFds[1]);
+
+    // Read the display number from the pipe
+    QFile readPipe;
+    if (!readPipe.open(pipeFds[0], QIODevice::ReadOnly)) {
+        qCritical("Failed to open pipe to start X Server");
+        ::close(pipeFds[0]);
+        return false;
+    }
+    QByteArray displayNumber = readPipe.readLine();
+    if (displayNumber.size() < 2) {
+        // X server gave nothing (or a whitespace)
+        qCritical("Failed to read display number from pipe");
+        ::close(pipeFds[0]);
+        return false;
+    }
+    displayNumber.prepend(QByteArray(":"));
+    displayNumber.remove(displayNumber.size() -1, 1); // trim trailing whitespace
+    m_display = QString::fromLocal8Bit(displayNumber);
+    qDebug("X11 display: %s", qPrintable(m_display));
+    Q_EMIT displayChanged(m_display);
+
+    // Generate xauthority file
+    // For the X server's copy, the display number doesn't matter.
+    // An empty file would result in no access control!
+    if (!m_xauth.addCookie(m_display)) {
+        qCritical("Failed to write xauth file");
+        return false;
+    }
+
+    // Close our pipe
+    ::close(pipeFds[0]);
+
+    return true;
+}
+
+void XOrgUserHelper::startDisplayCommand()
+{
+    auto env = QProcessEnvironment::systemEnvironment();
+    env.insert(QStringLiteral("DISPLAY"), m_display);
+    env.insert(QStringLiteral("XAUTHORITY"), m_xauth.authPath());
+
+    // Set cursor
+    qInfo("Setting default cursor...");
+    QProcess *setCursor = nullptr;
+    if (startProcess(QStringLiteral("xsetroot -cursor_name left_ptr"), env, &setCursor)) {
+        if (!setCursor->waitForFinished(1000)) {
+            qWarning() << "Could not setup default cursor";
+            setCursor->kill();
+        }
+        setCursor->deleteLater();
+    }
+
+    // Display setup script
+    auto cmd = mainConfig.X11.DisplayCommand.get();
+    qInfo("Running display setup script: %s", qPrintable(cmd));
+    QProcess *displayScript = nullptr;
+    if (startProcess(cmd, env, &displayScript)) {
+        if (!displayScript->waitForFinished(30000))
+            displayScript->kill();
+        displayScript->deleteLater();
+    }
+}
+
+void XOrgUserHelper::displayFinished()
+{
+    auto cmd = mainConfig.X11.DisplayStopCommand.get();
+    qInfo("Running display stop script: %s", qPrintable(cmd));
+    QProcess *displayStopScript = nullptr;
+    if (startProcess(cmd, sessionEnvironment(), &displayStopScript)) {
+        if (!displayStopScript->waitForFinished(5000))
+            displayStopScript->kill();
+        displayStopScript->deleteLater();
+    }
+
+    // Remove xauthority file
+    QFile::remove(m_xauth.authPath());
+}
+
+} // namespace SDDM
diff --git a/src/helper/xorguserhelper.h b/src/helper/xorguserhelper.h
new file mode 100644
index 0000000..286ca89
--- /dev/null
+++ b/src/helper/xorguserhelper.h
@@ -0,0 +1,67 @@
+/***************************************************************************
+* Copyright (c) 2021 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the
+* Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+***************************************************************************/
+
+#ifndef XORGUSERHELPER_H
+#define XORGUSERHELPER_H
+
+#include <QProcess>
+
+#include "XAuth.h"
+
+namespace SDDM {
+
+class XOrgUserHelper : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(QString display READ display NOTIFY displayChanged)
+public:
+    explicit XOrgUserHelper(QObject *parent = nullptr);
+
+    QProcessEnvironment environment() const;
+    void setEnvironment(const QProcessEnvironment &env);
+
+    /// @returns the same as @m environment plus the variables we need here
+    QProcessEnvironment sessionEnvironment() const;
+
+    QString display() const;
+
+    QString xauthPath() const;
+
+    bool start(const QString &cmd);
+    void stop();
+
+Q_SIGNALS:
+    void displayChanged(const QString &display);
+
+private:
+    QString m_display = QStringLiteral(":0");
+    XAuth m_xauth;
+    QProcessEnvironment m_environment;
+    QProcess *m_serverProcess = nullptr;
+
+    bool startProcess(const QString &cmd, const QProcessEnvironment &env,
+                      QProcess **p = nullptr);
+    bool startServer(const QString &cmd);
+    void startDisplayCommand();
+    void displayFinished();
+};
+
+} // namespace SDDM
+
+#endif // XORGUSERHELPER_H
